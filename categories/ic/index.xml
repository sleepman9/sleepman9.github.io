<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IC on UNO's Page</title><link>https://sleepman9.github.io/categories/ic/</link><description>Recent content in IC on UNO's Page</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 09 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://sleepman9.github.io/categories/ic/index.xml" rel="self" type="application/rss+xml"/><item><title>IC前端设计练习</title><link>https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/</guid><description>&lt;img src="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/cover.png" alt="Featured image of post IC前端设计练习" /&gt;&lt;h2 id="verilog练习网址"&gt;Verilog练习网址
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://edu.eeeknow.com/exam/lab?uname=1138b6c7f20ffa138c04c6b81515e990&amp;amp;clname=wx" target="_blank" rel="noopener"
&gt;verilog在线练习&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://digitalasic.design/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3/hdlbits-chinese/" target="_blank" rel="noopener"
&gt;中文HDLBits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/wszwszwszqwer/article/details/123764784" target="_blank" rel="noopener"
&gt;HDLBits完整版刷题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.zhihu.com/question/348990787" target="_blank" rel="noopener"
&gt;优秀的开源项目&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="verilog语法"&gt;verilog语法
&lt;/h2&gt;&lt;h3 id="default_nettype-none"&gt;`default_nettype none
&lt;/h3&gt;&lt;p&gt;// Disable implicit nets. Reduces some types of bugs.
这是一个编译器指令（以反引号 ` 开头），不是 Verilog 语言的一部分。&lt;/p&gt;
&lt;p&gt;设置当前源文件中，未显式声明的信号，不允许被自动推断为 wire。&lt;/p&gt;
&lt;p&gt;隐式 nets 通常是难以检测的错误源。在 Verilog 中，通过赋值语句或将未声明的内容连接到模块端口，可以隐式创建网络类型信号。隐式 nets 始终是单一位宽的导线，并且如果你打算使用向量，它会导致错误。可以使用 default_nettype none 指令禁用隐式 nets 的创建。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-verilog" data-lang="verilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 两个向量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b101&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// a = 101
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// b = 1 隐式创建的导线
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// c = 001 &amp;lt;-- 错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;my_module&lt;/span&gt; &lt;span class="n"&gt;i1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 如果没有声明，d 和 e 隐式地是单一位宽。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;// 如果端口本应是向量，这可能是一个错误。&lt;/p&gt;
&lt;p&gt;添加 default_nettype none 将使代码的第二行成为一个错误，这使得错误更容易被发现。&lt;/p&gt;
&lt;h3 id="组合逻辑"&gt;组合逻辑
&lt;/h3&gt;&lt;p&gt;用于硬件综合的always块有两种：&lt;/p&gt;
&lt;p&gt;• 组合逻辑：always @(*)&lt;/p&gt;
&lt;p&gt;• 时钟触发：always @(posedge clk)&lt;/p&gt;
&lt;p&gt;对于组合逻辑的always块，应始终使用(&lt;code&gt;*&lt;/code&gt;) 敏感列表，显式列出信号容易出错，且在硬件综合时会被忽略。如果错过某个信号，综合后的硬件行为仍会像指定了(*)一样，但仿真时会不同步。在assign语句中，左侧必须是网络类型（如wire），而在always块的过程赋值中，左侧必须是变量类型（如reg）。这些类型与硬件综合无关，仅是Verilog作为硬件仿真语言的语法遗留。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个“人口计数”电路用于计算输入向量中'1&amp;rsquo;的数量。构建一个用于3位输入向量的人口计数电路。&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-verilog" data-lang="verilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;top_module&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// assign out = in[0] + in[1] + in[2];
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// 一直在报!!!!!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-1.png"
width="1134"
height="675"
srcset="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-1_hu_3951abdcfab3e8d0.png 480w, https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-1_hu_e339074d26b7e883.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="403px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-2.png"
width="900"
height="630"
srcset="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-2_hu_e99c9dfd220514d1.png 480w, https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-2_hu_1e89b388b2fd7e84.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
&gt;
如果类型不对，会出现语法错误。&lt;/p&gt;
&lt;h3 id="条件运算符三元运算符"&gt;条件运算符（三元运算符）
&lt;/h3&gt;&lt;p&gt;用来实现 组合逻辑中基于选择信号的多路选择器（MUX）功能&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;condition ? true_value : false_value;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="link" href="https://edu.eeeknow.com/video-series?goods_sn=TW100943&amp;amp;series_goods_sn=XL101041&amp;amp;is_single=1&amp;amp;id=6019" target="_blank" rel="noopener"
&gt;https://edu.eeeknow.com/video-series?goods_sn=TW100943&amp;series_goods_sn=XL101041&amp;is_single=1&amp;id=6019&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="阻塞赋值和非阻塞赋值"&gt;阻塞赋值和非阻塞赋值
&lt;/h3&gt;&lt;p&gt;注意时序电路设计中的赋值语句要使用非阻塞赋值“&amp;lt;=”&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_44933149/article/details/121926211" target="_blank" rel="noopener"
&gt;阻塞赋值和非阻塞赋值&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="异步复位"&gt;异步复位
&lt;/h3&gt;&lt;p&gt;在任意时刻（不依赖时钟边沿），只要复位信号有效（通常是低电平或高电平），寄存器立即被清零（或设置为初始值）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对比项&lt;/th&gt;
&lt;th&gt;异步复位&lt;/th&gt;
&lt;th&gt;同步复位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;触发时机&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;立即生效&lt;/strong&gt;，与时钟无关&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;在时钟上升沿/下降沿生效&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;写法位置&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if (!rst)&lt;/code&gt; 在 &lt;code&gt;always&lt;/code&gt; 开头&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if (!rst)&lt;/code&gt; 放在 &lt;code&gt;clk&lt;/code&gt; 相关逻辑内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;响应速度&lt;/td&gt;
&lt;td&gt;快速响应，适合紧急清零&lt;/td&gt;
&lt;td&gt;与时钟同步，响应稍慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;通常用途&lt;/td&gt;
&lt;td&gt;系统启动、电源不稳恢复&lt;/td&gt;
&lt;td&gt;有严格时序控制的系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="地址数x字长"&gt;地址数x字长
&lt;/h3&gt;&lt;p&gt;我们常说的8x1 存储器&lt;/p&gt;
&lt;p&gt;“8” 表示地址数（也就是存储单元个数），
“1” 表示每个存储单元可以存储1位（bit）的数据。&lt;/p&gt;
&lt;h2 id="逻辑"&gt;逻辑
&lt;/h2&gt;&lt;h3 id="移位寄存器"&gt;移位寄存器
&lt;/h3&gt;&lt;p&gt;question：
我们现在有一个模块my_dff8，该模块具有两个输入和一个输出（实现一个8位的D触发器）。实例化它们中的三个，然后将它们链接在一起以构成一个长度为3的8位宽移位寄存器。
此外，创建一个4比1多路复用器，该多路复用器根据sel [1：0]选择输出的内容：输入d的值，在第一个，第二个之后或在第三个D触发器之后。 （&lt;strong&gt;本质上，sel选择从0到3个时钟周期延迟输入的周期。&lt;/strong&gt;）
提供模块是：
module my_dff8 ( input clk, input [7:0] d, output [7:0] q );
没有提供多路复用器。一种可能的写方法是在always块中包含case语句。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/image.png"
loading="lazy"
alt="移位寄存器"
&gt;&lt;/p&gt;
&lt;h3 id="真值表"&gt;真值表
&lt;/h3&gt;&lt;p&gt;SOP方法：输入使用“乘积”的形式，将每个为真的输出当作与门的输入&lt;/p&gt;
&lt;p&gt;卡诺图：得出电路表达式&lt;/p&gt;
&lt;h3 id="有符号溢出"&gt;有符号溢出
&lt;/h3&gt;&lt;p&gt;这里从溢出发生的情形出发解题，有符号数溢出有两种情况：一是正正相加，产生正溢出;另一种情况是负负相减，产生负溢出。所以就分别考虑了这两种情况，将这两种情况取或判断溢出。&lt;/p&gt;
&lt;p&gt;a[7] &amp;amp;&amp;amp; b[7] &amp;amp;&amp;amp; ~s[7]：&lt;/p&gt;
&lt;p&gt;负数相减（补码相加）产生正数，判断溢出。&lt;/p&gt;
&lt;p&gt;~a[7] &amp;amp;&amp;amp; ~b[7] &amp;amp;&amp;amp; s[7]：&lt;/p&gt;
&lt;p&gt;正数相加产生一个负数，判断溢出。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;情况&lt;/th&gt;
&lt;th&gt;a[7]&lt;/th&gt;
&lt;th&gt;b[7]&lt;/th&gt;
&lt;th&gt;s[7]&lt;/th&gt;
&lt;th&gt;是否溢出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;正 + 正 = 负&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;✅ 溢出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;负 + 负 = 正&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;✅ 溢出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其余情况&lt;/td&gt;
&lt;td&gt;0/1&lt;/td&gt;
&lt;td&gt;1/0&lt;/td&gt;
&lt;td&gt;无论什么&lt;/td&gt;
&lt;td&gt;❌ 不溢出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;举个例子：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;a = 1000_0000 = -128
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;b = 1000_0000 = -128
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;s = a + b = -128 + (-128) = -256
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;但 8 位补码最大表示范围是 [-128, 127]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-256 超出范围，结果会变成：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;s = 0000_0000 （实际为 0） → s[7] = 0 ⇒ 溢出
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;a = 0111_1111 = 127
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;b = 0000_0001 = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;s = a + b = 127 + 1 = 128
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;但 8 位补码最大表示范围是 [-128, 127]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;128 超出范围，结果会变成：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;s = 1000_0000 （实际为 -128） → s[7] = 1 ⇒ 溢出
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="边沿检查时序逻辑检查"&gt;边沿检查（时序逻辑检查）
&lt;/h3&gt;&lt;p&gt;位级并行上升沿检测（rising edge detection）问题，目标是检测一个 8 位信号向量中每一位何时发生 从 0 到 1 的变化，即上升沿，并在下一个时钟周期将相应输出位设为 1（其他位为 0）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键：确定上一个时钟周期的信号，使用 与门过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://edu.eeeknow.com/video-series?goods_sn=TW100943&amp;amp;series_goods_sn=XL101041&amp;amp;is_single=1&amp;amp;id=6019" target="_blank" rel="noopener"
&gt;练习题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;🧠 基本原理：&lt;/p&gt;
&lt;p&gt;对于一个信号 in[7:0]，我们需要对每一位 in[i] 做如下逻辑：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-verilog" data-lang="verilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;in_dly&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中：
in_dly[i] 是 in[i] 的上一个周期值（通过寄存器存下来的）。
out[i] 是当前周期输出的上升沿信号。&lt;/p&gt;
&lt;p&gt;这条表达式的意思是：
如果 上一个周期是0 且 当前周期是1，说明发生了上升沿。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;假设输入信号 in[7:0] 在 4 个时钟周期内的值如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Cycle&lt;/th&gt;
&lt;th&gt;&lt;code&gt;in[7:0]&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00010010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00010011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00010001&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们期望输出 out[7:0] 为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Cycle&lt;/th&gt;
&lt;th&gt;&lt;code&gt;out[7:0]&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00000000&lt;/td&gt;
&lt;td&gt;初始周期，没有比较基础&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00010010&lt;/td&gt;
&lt;td&gt;第1位和第4位从 0→1，上升沿检测到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00000001&lt;/td&gt;
&lt;td&gt;第0位从 0→1 出现上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00000000&lt;/td&gt;
&lt;td&gt;没有新的上升沿，out 全为0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description></item><item><title>扫描链测试（scan chain）</title><link>https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/cover.png" alt="Featured image of post 扫描链测试（scan chain）" /&gt;&lt;h2 id="扫描链测试scan-chain"&gt;扫描链测试（scan chain）
&lt;/h2&gt;&lt;p&gt;在芯片功能设计完成后，整个网表是由一堆普通的寄存器和组合逻辑构成的。扫描链的插入就是指将普通寄存器替换成为扫描寄存器（scan flip-flop）的过程。&lt;/p&gt;
&lt;p&gt;SE scan enable为其切换信号。正常工作模式时，SE为0，这时scan FF的功能与原有的D-FF完全一致，data path 为D到Q。芯片的功能得以保持不变。当SE被切换为1时，这时候scan FF执行其scan属性，data path为SI到Q。SI即为测试时的数据流向入口。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image.png"
width="500"
height="224"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image_hu_cf54673001196058.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image_hu_59d7b13743d1e922.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="223"
data-flex-basis="535px"
&gt;&lt;/p&gt;
&lt;p&gt;Function         SE=0       datapath：D-&amp;gt;Q       scan FF act as DFF&lt;/p&gt;
&lt;p&gt;Scan               SE=1       datapath: SI-&amp;gt;Q       Scan FF act as Scan&lt;/p&gt;
&lt;p&gt;将片上的扫描寄存器Q-SI连接起来，就成为了扫描链。通过shift的方式可以由scan chain将数据串行输入的每个寄存器的SI端，达到控制每个寄存器的目的。在capture模式下，将芯片组合逻辑的反馈传回寄存器，达到对芯片内部观测的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-1.png"
width="447"
height="314"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-1_hu_9906b7906d9e30a3.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-1_hu_a29bc341eae0ad70.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="341px"
&gt;&lt;/p&gt;
&lt;h3 id="step-1"&gt;Step 1
&lt;/h3&gt;&lt;p&gt;DFT 第一步是做 scan chain，首先将电路中的普通 DFF 换成 scan DFF：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-2.png"
width="714"
height="249"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-2_hu_c85d2f36c0cdc86c.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-2_hu_625aeec730f6d0bc.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="286"
data-flex-basis="688px"
&gt;&lt;/p&gt;
&lt;p&gt;scan DFF 是在原DFF 的输入端增加了一个 MUX，于是多了几个 pin ：scan_in，scan_enable，scan_out&lt;/p&gt;
&lt;p&gt;换完之后将所有的 scan DFF 首尾依次串接起来，就构成了一条 scan chain ：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-3.png"
width="697"
height="216"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-3_hu_e8f5483829e4e1c6.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-3_hu_b8418e3b153a2ed8.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="774px"
&gt;&lt;/p&gt;
&lt;p&gt;当 SE 信号（即 scan enable ）有效时，电路进入scan 状态，此时数据通路如下图蓝色粗线所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-4.png"
width="679"
height="225"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-4_hu_8bf764e1878ea1c0.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-4_hu_2b978a9c1e543e1d.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="301"
data-flex-basis="724px"
&gt;&lt;/p&gt;
&lt;p&gt;当 SE 信号无效时，电路工作在 normal 状态，数据通路如下图红色粗线所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-5.png"
width="704"
height="241"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-5_hu_b963b9ca1aae0f69.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-5_hu_15421e1a6079f800.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="292"
data-flex-basis="701px"
&gt;&lt;/p&gt;
&lt;p&gt;那么，这样一条 scan chain 是如何检测到电路中的缺陷呢？&lt;/p&gt;
&lt;p&gt;简单来讲，scan chain 工作时分为三个步骤： load ····&amp;gt;  capture ····&amp;gt; unload&lt;/p&gt;
&lt;p&gt;load 是将input pattern 打入 scan chain&lt;/p&gt;
&lt;p&gt;capture 是将每一级组合逻辑的结果打入下一级register&lt;/p&gt;
&lt;p&gt;unload 是将scan chain 中的数据串行输出，得到 output pattern&lt;/p&gt;
&lt;p&gt;下图是一个简单的 scan chain 工作原理示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-6.png"
width="1500"
height="1019"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-6_hu_b468ea03b6c658ec.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-6_hu_f166173df88855a9.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="353px"
&gt;&lt;/p&gt;
&lt;p&gt;结合上图，可知scan mode 的工作步骤如下：&lt;/p&gt;
&lt;p&gt;1. 将普通的 register 替换为 scan register&lt;/p&gt;
&lt;p&gt;2. 将 scan register 首尾依次串接起来&lt;/p&gt;
&lt;p&gt;3. 在 SE 有效拉高时，将 input pattern 串行打入scan register&lt;/p&gt;
&lt;p&gt;4. 然后 SE 拉低，等 Reg/Q 的值经过组合逻辑运算后到达下一级 reg 的D 端&lt;/p&gt;
&lt;p&gt;5. 再产生一个 capture pulse 将 D 端的值打入寄存器&lt;/p&gt;
&lt;p&gt;6. 最后 SE 拉高，将 reg 中的值依次串行输出，得到 output pattern&lt;/p&gt;
&lt;p&gt;7. 如果 output  pattern 和预期的输出结果相同，说明电路工作正常&lt;/p&gt;
&lt;h2 id="link"&gt;Link
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://vlsitutorials.com/dft-scan-and-atpg/" target="_blank" rel="noopener"
&gt;VLSI Tutorials&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.jianshu.com/p/b2ae98596801" target="_blank" rel="noopener"
&gt;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>IC_后端输入文件</title><link>https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/</link><pubDate>Wed, 27 Aug 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/</guid><description>&lt;h2 id="后端设计需要导入的设计文件"&gt;后端设计需要导入的设计文件
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;逻辑综合后的网表netlist（门级）&amp;mdash;-解决实现什么样的功能&lt;br&gt;
​&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825103724-g56889z.png"
width="663"
height="444"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825103724-g56889z_hu_137e590ba85e52c0.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825103724-g56889z_hu_1045f3bb187d769a.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
&gt;​&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;定义了大量与扫描链（scan chain）相关的信号，用于测试和调试。&lt;/li&gt;
&lt;li&gt;包含了用于时钟分频和复位处理的电路。&lt;/li&gt;
&lt;li&gt;实例化了子模块（如 mcore 和 proc），可能构成了一个完整的处理器或系统核心。&lt;/li&gt;
&lt;li&gt;涉及 AHB 总线接口、数据传输和控制信号的传递和管理。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;p&gt;lef文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;lef 和 def 区别：&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;lef:只告诉你“元器件长什么样、能放哪、怎么连”&lt;/p&gt;
&lt;p&gt;元器件的物理规则和抽象几何模型&lt;/p&gt;
&lt;p&gt;可以理解为：&lt;strong&gt;LEF&lt;/strong&gt; &lt;strong&gt;=&lt;/strong&gt; &lt;strong&gt;Cell/工艺的物理蓝图 + 设计规则&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;def：&lt;/p&gt;
&lt;p&gt;设计中元器件的放置和布线实现&lt;/p&gt;
&lt;p&gt;可以理解为：&lt;strong&gt;DEF&lt;/strong&gt; &lt;strong&gt;=&lt;/strong&gt; &lt;strong&gt;你的设计的实际布局布线结果&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;
&lt;p&gt;lib文件：std的属性&lt;br&gt;
​&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105054-lf9lfqe.png"
width="698"
height="485"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105054-lf9lfqe_hu_69e11e6a551b2f5c.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105054-lf9lfqe_hu_534262c662fbaa76.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="345px"
&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;timing libraries&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105539-vhgfwp0.png"
width="529"
height="203"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105539-vhgfwp0_hu_e263c146189d7aa7.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105539-vhgfwp0_hu_cbf81882992d27ad.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="260"
data-flex-basis="625px"
&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;timing constraints（SDC）&lt;br&gt;
​&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105707-htzsbb7.png"
width="676"
height="65"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105707-htzsbb7_hu_68acadcfd460e4f4.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105707-htzsbb7_hu_56c4deee82cc6598.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="1040"
data-flex-basis="2496px"
&gt;​&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105756-ba2b9du.png"
width="681"
height="537"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105756-ba2b9du_hu_5bf24e7101061525.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105756-ba2b9du_hu_69d57bab74ef36c7.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="304px"
&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="clock-tree-debug"&gt;clock tree debug
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://www.jianshu.com/p/1e84d86ab3c7" target="_blank" rel="noopener"
&gt;Clock Tree Debugger&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Job</title><link>https://sleepman9.github.io/p/job/</link><pubDate>Mon, 04 Aug 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/job/</guid><description>&lt;h2 id="前端"&gt;前端
&lt;/h2&gt;&lt;h2 id="验证"&gt;验证
&lt;/h2&gt;&lt;h2 id="后端"&gt;后端
&lt;/h2&gt;&lt;h3 id="url"&gt;URL
&lt;/h3&gt;&lt;p&gt;&lt;a class="link" href="https://www.nowcoder.com/discuss/353158032005734400" target="_blank" rel="noopener"
&gt;牛客———【数字IC后端岗】校招笔试如何准备？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="1什么是天线效应如何修复华为海思"&gt;1、什么是天线效应？如何修复？【华为海思】
&lt;/h3&gt;&lt;p&gt;（生产过程中）由于等离子刻蚀法使金属刻蚀过程中收集大量空间静电电荷，当金属积累的静电电荷超过一定数量，形成的电势超过它所接连门栅所能承受的击穿电压时，晶体管就会被击穿，导致器件损坏，这就是天线效应。&lt;/p&gt;
&lt;p&gt;在芯片生产过程中，暴露的金属线或者多晶硅（polysilicon）等导体，就象是一根根天线，会收集电荷（如等离子刻蚀产生的带电粒子）导致电位升高。天线越长，收集的电荷也就越多，电压就越高。若这片导体碰巧只接了MOS 的栅，那么高电压就可能把薄栅氧化层击穿，使电路失效，这种现象我们称之为“天线效应”。&lt;/p&gt;
&lt;p&gt;修复的方法:核心原理，释放天线上的电荷。&lt;br&gt;
&lt;a class="link" href="https://blog.csdn.net/qq_38328278/article/details/118544550#:~:text=%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20*%203.1%20%E8%B7%B3%E7%BA%BF%E6%B3%95%20%E5%B0%86%E6%9C%89%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E9%87%91%E5%B1%9E%E7%BA%BF%E6%89%93%E6%96%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E9%80%9A%E5%AD%94%E5%90%91%E4%B8%8A%E6%88%96%E5%90%91%E4%B8%8B%EF%BC%8C%E5%86%8D%E9%80%9A%E8%BF%87%E9%80%9A%E5%AD%94%E5%9B%9E%E5%88%B0%E8%AF%A5%E5%B1%82%E3%80%82%20%E8%B7%B3%E7%BA%BF%E7%BC%A9%E5%B0%8F%E4%BA%86%E9%87%91%E5%B1%9E%E8%BF%9E%E7%BA%BF%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%9B%A0%E8%80%8C%E8%B5%B7%E5%88%B0%E5%87%8F%E5%B0%8F%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82%20%E4%BD%86%E9%80%9A%E5%AD%94%E7%9A%84%E7%94%B5%E9%98%BB%E8%BE%83%E5%A4%A7%EF%BC%8C%E4%BC%9A%E5%BD%B1%E5%93%8D%E8%8A%AF%E7%89%87%E7%9A%84%E6%97%B6%E5%BA%8F%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AF%E8%83%BD%E5%9C%A8%E5%85%B6%E4%BB%96%E5%B1%82%E5%B8%A6%E6%9D%A5%E4%B8%B2%E6%89%B0%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82,%E7%A7%91%E5%AD%A6%E5%90%88%E7%90%86%E7%9A%84PCB%E8%AE%BE%E8%AE%A1%E9%9C%80%E4%BB%8E%E7%94%B5%E6%BA%90%E6%8E%A7%E5%88%B6%E5%85%A5%E6%89%8B%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%9B%9E%E6%B5%81%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%EF%BC%8C%E6%89%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%B7%B7%E5%90%88%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F%E3%80%82%20%E7%BB%A7%E7%BB%AD%E8%AE%BF%E9%97%AE%20%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E7%90%86%E5%8F%8A%E6%B6%88%E9%99%A4%E6%96%B9%E6%B3%95%20%E5%AF%BC%E8%AF%BB%EF%BC%9A%E9%9A%8F%E7%9D%80%E5%B7%A5%E8%89%BA%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%EF%BC%8C%E6%A0%85%E7%9A%84%E5%B0%BA%E5%AF%B8%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%B0%8F%EF%BC%8C%E9%87%91%E5%B1%9E%E7%9A%84%E5%B1%82%E6%95%B0%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%EF%BC%8C%E5%8F%91%E7%94%9F%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7%E5%B0%B1%E8%B6%8A%E5%A4%A7%E3%80%82%20%E8%80%8C%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E5%88%99%E4%BC%9A%E5%AF%B9%E5%B0%8F%E5%9E%8B%E6%8A%80%E6%9C%AF%E9%A2%86%E5%9F%9F%E4%BA%A7%E7%94%9F%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%B3%84%E7%94%B5%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%8D%9F%E5%AE%B3%E5%BE%88%E5%8F%AF%E8%83%BD%E6%B3%A2%E5%8F%8A%E6%95%B4%E4%B8%AA%E6%A0%85%E6%9E%81%E3%80%82%20%E5%9B%A0%E6%AD%A4%EF%BC%8C%E6%9C%AC%E6%96%87%E5%AF%B9%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E7%90%86%E5%8F%8A%E6%B6%88%E9%99%A4%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95%E5%81%9A%E5%87%BA%E4%BA%86%E8%AE%A8%E8%AE%BA%E3%80%82%201.%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E6%88%96%E7%AD%89%E7%A6%BB%E5%AD%90%E5%AF%BC%E8%87%B4%E6%A0%85%E6%B0%A7%E6%8D%9F%E4%BC%A4%E6%98%AF%E6%8C%87%EF%BC%9A%E5%9C%A8MOS%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%B8%80%E7%A7%8D%E5%8F%AF%E6%BD%9C%E5%9C%A8%E5%BD%B1%E5%93%8D%E4%BA%A7%E5%93%81%E4%BA%A7%E9%87%8F%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E6%95%88%E5%BA%94%E3%80%82" target="_blank" rel="noopener"
&gt;天线效应产生原因及解决办法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（1）插入Diode二极管（保护二极管，反偏二极管）；
原理:在有天线效应的金属线上插入一个反向偏置的二极管。当金属线上积累的电荷达到一定程度时，二极管会导通(&amp;gt;0.7v)，形成到地的通路，从而释放积累的电荷，减少天线效应。&lt;/p&gt;
&lt;p&gt;优点:可以有效抑制电荷积累，降低天线效应。&lt;br&gt;
缺点:增加了芯片面积，不适用于大规模集成电路。&lt;/p&gt;
&lt;p&gt;（2）向上跳线法&lt;br&gt;
原理：跳线法通过打断有天线效应的金属线，然后通过通孔将其连接到其他金属层，再回到原层，以此来改变金属布线的长度和路径，从而降低天线效应。&lt;br&gt;
类型：跳线法主要分为向上跳线和向下跳线两种方式。向上跳线是将金属线连接到天线层上一层，向下跳线则连接到下一层。&lt;/p&gt;
&lt;p&gt;优点:相对简单，容易实现。&lt;br&gt;
缺点:通孔会增加电阻，可能影响芯片的时序和串扰问题。&lt;/p&gt;
&lt;p&gt;（3）size up cell&lt;br&gt;
原理：增加 cell 的栅极面积（denominator 增大）→ 减小天线比&lt;br&gt;
通过将原先的 cell 替换为更大版本的 cell（比如从 NAND2_X1 换成 NAND2_X4）：&lt;/p&gt;
&lt;p&gt;$ \text{Antenna Ratio} = \frac{\text{未连接金属的面积}}{\text{栅极面积}} $&lt;/p&gt;
&lt;p&gt;栅极面积增加（例如变成原来的 2 倍或 4 倍）；&lt;/p&gt;
&lt;p&gt;天线比自然降低，可能就会小于工艺允许的最大值；&lt;/p&gt;
&lt;p&gt;这样就避免了额外插入天线二极管、或断线、或插入 buffer 的复杂处理。&lt;/p&gt;
&lt;h3 id="2芯片tapeout前要做哪些检查华为海思"&gt;2、芯片tapeout前要做哪些检查？【华为海思】
&lt;/h3&gt;&lt;p&gt;时序（setup/hold）检查，后仿，DRC/LVS，电气规则检查ERC，DFM（可制造性设计），LEC（等价性检查）&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;点击展开所有详细信息&lt;/summary&gt;
&lt;p&gt;✅ 1. 时序检查（Setup/Hold）&lt;/p&gt;
&lt;p&gt;目的：确保芯片在工作频率下功能正确，不发生时序错误。&lt;/p&gt;
&lt;p&gt;• Setup 检查：确保数据在时钟边沿到来前已稳定，满足 最小建立时间 要求。&lt;br&gt;
• Hold 检查：确保数据在时钟边沿后仍保持足够时间不变，满足 保持时间 要求。&lt;br&gt;
• 采用 STA 工具（如 PrimeTime），在多个 PVT（工艺、供电、温度）条件下验证时序。&lt;br&gt;
• 执行 OCV、cross corner 分析及多模多库（MMMC）分析，增强时序可靠性。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 2. 后仿（Gate-level simulation with SDF）&lt;/p&gt;
&lt;p&gt;目的：验证综合、布局布线后，在真实延迟条件下芯片功能是否正确。&lt;/p&gt;
&lt;p&gt;• 生成 post-layout netlist 和时延文件（SDF）后执行门级仿真。&lt;br&gt;
• 验证异步复位、锁存器、启动序列、扫描链、低功耗控制等关键功能。&lt;br&gt;
• 检查 glitch、亚稳态及不可预测状态。&lt;br&gt;
• 包括 scan chain、ATPG 模式及功能全覆盖仿真。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 3. DRC（Design Rule Check）设计规则检查&lt;/p&gt;
&lt;p&gt;目的：确保芯片物理布局满足 Foundry 提供的制造工艺设计规则。&lt;/p&gt;
&lt;p&gt;• 检查项目：金属宽度、间距、过孔密度、器件间隔、TSV/Pad 限制等。&lt;br&gt;
• 通过 PDK 中的规则文件和工具（如 Calibre、IC Validator）自动检查。&lt;br&gt;
• 所有 DRC 错误必须 100% 修复，才能提交流片申请。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 4. LVS（Layout Versus Schematic）版图与原理图对比&lt;/p&gt;
&lt;p&gt;目的：确保最终版图与 RTL 描述的功能一致。&lt;/p&gt;
&lt;p&gt;• 核对版图中每个晶体管及连接是否与 netlist 匹配。&lt;br&gt;
• 避免误连、漏连和短接等错误。&lt;br&gt;
• 工具有 Calibre LVS 和 PVS LVS。&lt;br&gt;
• ECO 修改后需重新进行 LVS 校验。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 5. ERC（Electrical Rule Check）电气规则检查&lt;/p&gt;
&lt;p&gt;目的：捕捉常见电气错误，如浮空输入、短路和电压兼容性问题。&lt;/p&gt;
&lt;p&gt;• 常见检查：&lt;br&gt;
  – 输入未驱动或浮空；&lt;br&gt;
  – 电源与地的短接；&lt;br&gt;
  – 跨电压域连接（需使用隔离 cell）；&lt;br&gt;
  – IO 驱动中的电压不匹配。&lt;br&gt;
• 对低功耗设计（多电压/多电源域）尤为重要。&lt;br&gt;
• 常用工具包括 Calibre ERC 和 Synopsys IC Validator。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 6. DFM（Design for Manufacturability）可制造性检查&lt;/p&gt;
&lt;p&gt;目的：提升芯片良率和生产可控性，预防制造缺陷。&lt;/p&gt;
&lt;p&gt;• 包含检查：&lt;br&gt;
  – 密度检查（metal density / slotting）；&lt;br&gt;
  – 填充检查（dummy fill）；&lt;br&gt;
  – 边缘放置错误；&lt;br&gt;
  – 光刻热点检测。&lt;br&gt;
• 根据 DFM 报告，工厂会反馈是否需要调整设计。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 7. LEC（Logic Equivalence Check）等价性检查&lt;/p&gt;
&lt;p&gt;目的：确保综合后的 gate-level netlist 与 RTL 功能完全等价。&lt;/p&gt;
&lt;p&gt;• 检查流程：&lt;br&gt;
  – 比较 RTL（黄金模型）和 gate-level netlist（目标模型）的输入、输出及逻辑路径。&lt;br&gt;
• 应用于综合后验证、ECO 及 Scan 插入后验证。&lt;br&gt;
• 常用工具：Cadence Conformal、Synopsys Formality。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;补充性检查&lt;/p&gt;
&lt;p&gt;检查项 说明&lt;br&gt;
────────────────────────&lt;br&gt;
IR Drop 分析 检查供电网络是否存在过大的电压下降，防止功能异常。&lt;br&gt;
EM（电迁移）分析 检查金属线因电流过大而可能出现的迁移问题。&lt;br&gt;
Crosstalk / SI 分析 分析耦合电容引起的时序干扰。&lt;br&gt;
Antenna Check 检查天线效应，判断是否需要增加 diode 或断开连接。&lt;br&gt;
Package/IO Check 验证 IO 电压、电流是否符合 Pad 规则以及电源完整性。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;华为海思等先进芯片设计公司在 Tapeout 前必须确保以下几点：&lt;br&gt;
功能正确（LEC、后仿） + 时序正确（STA） + 物理可靠（DRC/LVS/ERC/DFM） + 电气完整（IR Drop、EM、SI） + 制造可行（DFM）。&lt;/p&gt;
&lt;p&gt;缺一不可，否则可能导致芯片白流（白片）和巨额损失。如果在流程中的任何工具或步骤遇到问题，请提供具体日志或报错信息，以便进一步分析解决。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="3闩锁效应是什么怎么产生如何解决格科微"&gt;3、闩锁效应是什么，怎么产生如何解决？【格科微】
&lt;/h3&gt;&lt;p&gt;闩锁效应是CMOS工艺所特有的寄生效应，是指在芯片的电源和地之间存在一个低阻抗的通路，产生很大的电流，导致电路无法正常工作，甚至烧毁电路。严重会导致电路的失效，甚至烧毁芯片。闩锁效应是由NMOS的有源区、P衬底、N阱、PMOS的有源区构成的n-p-n-p结构产生的，当其中一个三极管正偏时，就会构成正反馈形成闩锁。避免闩锁的方法就是要减小衬底和N阱的寄生电阻，使寄生的三极管不会处于正偏状态&lt;/p&gt;
&lt;h3 id="4前后端的整个flow以及每一个步骤中会用到的工具芯原"&gt;4、前后端的整个flow，以及每一个步骤中会用到的工具【芯原】
&lt;/h3&gt;&lt;p&gt;前端：
（1）规格制定
芯片规格，也就像功能列表一样，是客户向芯片设计公司（称为 Fabless，无晶圆设计公司）提出的设计要求，包括芯片需要达到的具体功能和性能方面的要求。
（2）详细设计
Fabless根据客户提出的规格要求，拿出设计解决方案和具体实现架构，划分模块功能。&lt;/p&gt;
&lt;p&gt;（3）HDL编码
使用硬件描述语言（VHDL，Verilog HDL，业界公司一般都是使用后者）将模块功能以代码来描述实现，也就是将实际的硬件电路功能通过 HDL语言描述出来，形成 RTL（寄存器传输级）代码。&lt;/p&gt;
&lt;p&gt;（4）仿真验证
仿真验证就是检验编码设计的正确性，检验的标准就是（1）中制定的规格。看设计是否精确地满足了规格中的所有要求。规格是设计正确与否的黄金标准，一切违反，不符合规格要求的，就需要重新修改设计和编码。设计和仿真验证是反复迭代的过程，直到验证结果显示完全符合规格标准。
仿真验证工具 Synopsys 的VCS，还有Cadence的NC-Verilog。&lt;/p&gt;
&lt;p&gt;（5）逻辑综合――Design Compiler
仿真验证通过，进行逻辑综合。逻辑综合的结果就是把设计实现的 HDL代码翻译成门级网表 netlist。综合需要设定约束条件，就是你希望综合出来的电路在面积，时序等目标参数上达到的标准。逻辑综合需要基于特定的综合库，不同的库中，门电路基本标准单元（standard cell）的面积，时序参数是不一样的。所以，选用的综合库不一样，综合出来的电路在时序，面积上是有差异的。 一般来说，综合完成后需要再次做仿真验证（这个也称为后仿真，之前的称为前仿真）
逻辑综合工具 Synopsys 的 Design Compiler。&lt;/p&gt;
&lt;p&gt;（6）STA
Static Timing Analysis（STA），静态时序分析，这也属于验证范畴，它主要是在时序上对电路进行验证，检查电路是否存在建立时间（setup time）和保持时间（hold time）的违例（violation） 。这个是数字电路基础知识，一个寄存器出现这两个时序违例时，是没有办法正确采样数据和输出数据的，所以以寄存器为基础的数字芯片功能肯定会出现问题。
STA工具有Synopsys 的Prime Time。&lt;/p&gt;
&lt;p&gt;（7）形式验证
这也是验证范畴，它是从功能上（STA 是时序上）对综合后的网表进行验证。常用的就是等价性检查方法，以功能验证后的 HDL 设计为参考，对比综合后的网表功能，他们是否在功能上存在等价性。这样做是为了保证在逻辑综合过程中没有改变原先 HDL描述的电路功能。
形式验证工具有 Synopsys 的Formality。&lt;/p&gt;
&lt;p&gt;前端设计的流程暂时写到这里。从设计程度上来讲，前端设计的结果就是得到了芯片的门级网表电路。&lt;/p&gt;
&lt;p&gt;后端：
（1）DFT
Design For Test，可测性设计。芯片内部往往都自带测试电路，DFT的目的就是在设计的时候就考虑将来的测试。DFT的常见方法就是，在设计中插入扫描链，将非扫描单元（如寄存器）变为扫描单元。关于 DFT，有些书上有详细介绍，对照图片就好理解一点。 DFT
工具 Synopsys 的DFT Compiler&lt;/p&gt;
&lt;p&gt;（2）布局规划(FloorPlan)
布局规划就是放置芯片的宏单元模块，在总体上确定各种功能电路的摆放位置，如 IP模块，RAM，I/O引脚等等。布局规划能直接影响芯片最终的面积。&lt;/p&gt;
&lt;p&gt;（3）CTS
Clock Tree Synthesis，时钟树综合，简单点说就是时钟的布线。由于时钟信号在数字芯片的全局指挥作用，它的分布应该是对称式的连到各个寄存器单元，从而使时钟从同一个时钟源到达各个寄存器时，时钟延迟差异最小。这也是为什么时钟信号需要单独布线的原因。&lt;/p&gt;
&lt;p&gt;（4）布线(Place &amp;amp; Route)
这里的布线就是普通信号布线了，包括各种标准单元（基本逻辑门电路）之间的走线。比如我们平常听到的 0.13um 工艺，或者说 90nm 工艺，实际上就是这里金属布线可以达到的最小宽度，从微观上看就是MOS管的沟道长度。
2-4的工具有Synopsys的ICC/ICC2和Cadence的Innovus&lt;/p&gt;
&lt;p&gt;（5）版图物理验证
对完成布线的物理版图进行功能和时序上的验证，验证项目很多，如 LVS（Layout Vs Schematic）验证，简单说，就是版图与逻辑综合后的门级电路图的对比验证；DRC（Design Rule Checking） ：设计规则检查，检查连线间距，连线宽度等是否满足工艺要求ERC（Electrical Rule Checking） ：电气规则检查，检查短路和开路等电气 规则违例；等等。
工具为Mentor的calibre&lt;/p&gt;
&lt;p&gt;（6）寄生参数提取
由于导线本身存在的电阻，相邻导线之间的互感,耦合电容在芯片内部会产生信号噪声，串扰和反射。这些效应会产生信号完整性问题，导致信号电压波动和变化，如果严重就会导致信号失真错误。提取寄生参数进行再次的分析验证，分析信号完整性问题是非常重要的。
工具 Synopsys的 Star-RCXT。
（7） STA
（8） post-simulation(前仿是功能仿真，后仿真需要考虑门和线延迟)，动态时序仿真，是对加入了延时信息的网表文件进行的仿真，目的是验证时序以及功能都正确。它主要应用在异步逻辑、多周期路径、错误路径的验证中。需要布局布线后生成的网表文件.v和SDF文件.sdf。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;点击展开所有详细信息&lt;/summary&gt;
前端和后端设计流程是芯片设计（特别是数字IC）的两个主要阶段。以下是整个 flow 的详细分解，并列出了每一步常用的工具：
&lt;hr&gt;
&lt;p&gt;💡 一、前端设计流程（Front-End）&lt;/p&gt;
&lt;p&gt;前端主要关注芯片的功能实现和时序验证，通常基于 RTL（寄存器传输级）代码。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;内容描述&lt;/th&gt;
&lt;th&gt;常用工具&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. 规格定义（Spec）&lt;/td&gt;
&lt;td&gt;定义芯片的功能、性能、功耗、接口等需求&lt;/td&gt;
&lt;td&gt;Word / Excel / 文档工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 架构设计&lt;/td&gt;
&lt;td&gt;定义模块划分、通信方式、时钟域、功耗域等&lt;/td&gt;
&lt;td&gt;手动设计、Visio / Draw.io&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. RTL 编码&lt;/td&gt;
&lt;td&gt;使用 Verilog / VHDL 进行功能逻辑描述&lt;/td&gt;
&lt;td&gt;VSCode, VIM, Emacs, Vivado, Design Compiler（用于综合前检查）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4. 功能仿真（Simulation）&lt;/td&gt;
&lt;td&gt;使用 Testbench 验证 RTL 是否符合功能需求&lt;/td&gt;
&lt;td&gt;ModelSim, VCS, XSIM, Riviera-PRO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5. 形式验证（Formal）&lt;/td&gt;
&lt;td&gt;静态方式验证 RTL 是否存在死锁、冲突等逻辑问题&lt;/td&gt;
&lt;td&gt;JasperGold, VC Formal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6. 时序约束编写&lt;/td&gt;
&lt;td&gt;编写 .sdc（Synopsys Design Constraints）时序约束&lt;/td&gt;
&lt;td&gt;手写 or 使用工具生成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7. RTL 综合（Synthesis）&lt;/td&gt;
&lt;td&gt;将 RTL 转换成门级网表（Gate-level Netlist）&lt;/td&gt;
&lt;td&gt;Synopsys Design Compiler, Cadence Genus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8. 功能等价验证（LEC）&lt;/td&gt;
&lt;td&gt;验证综合后的网表与原始 RTL 是否等价&lt;/td&gt;
&lt;td&gt;Conformal LEC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;🛠️ 二、后端设计流程（Back-End）&lt;/p&gt;
&lt;p&gt;后端主要关注芯片物理实现，保证其在物理上可行并满足性能要求。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;内容描述&lt;/th&gt;
&lt;th&gt;常用工具&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. Floorplan（平面图）&lt;/td&gt;
&lt;td&gt;芯片初始布局，决定核心区域、IO 放置等&lt;/td&gt;
&lt;td&gt;Innovus, ICC2, Aprisa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. Power Planning&lt;/td&gt;
&lt;td&gt;电源网络设计，如 VDD/VSS 分布、power ring 等&lt;/td&gt;
&lt;td&gt;Innovus, RedHawk（IR drop 分析）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. Placement（布局）&lt;/td&gt;
&lt;td&gt;把门级网表中的单元在芯片上进行物理位置布局&lt;/td&gt;
&lt;td&gt;Innovus, ICC2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4. CTS（时钟树综合）&lt;/td&gt;
&lt;td&gt;构建稳定的时钟网络，使所有单元得到同步时钟&lt;/td&gt;
&lt;td&gt;Innovus CTS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5. Routing（布线）&lt;/td&gt;
&lt;td&gt;连接所有逻辑单元引脚，并满足 DRC、timing 等约束&lt;/td&gt;
&lt;td&gt;Innovus, ICC2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6. 时序分析 STA&lt;/td&gt;
&lt;td&gt;静态时序分析，检查 setup/hold violations&lt;/td&gt;
&lt;td&gt;PrimeTime, Tempus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7. DRC（版图规则检查）&lt;/td&gt;
&lt;td&gt;确保物理布局满足制造工艺的规则&lt;/td&gt;
&lt;td&gt;Calibre, Pegasus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8. LVS（电路布局一致性）&lt;/td&gt;
&lt;td&gt;比较网表与版图，确保物理布局和逻辑一致&lt;/td&gt;
&lt;td&gt;Calibre LVS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9. IR drop / EM 分析&lt;/td&gt;
&lt;td&gt;电源完整性分析，检查电压下降和电迁移等问题&lt;/td&gt;
&lt;td&gt;RedHawk, Voltus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10. 寄生参数提取（PEX）&lt;/td&gt;
&lt;td&gt;从布线中提取电容、电阻信息，用于后仿和时序分析&lt;/td&gt;
&lt;td&gt;StarRC, QRC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11. 后仿（Gate-level sim）&lt;/td&gt;
&lt;td&gt;含寄生的门级网表后仿，验证综合后逻辑功能及时序&lt;/td&gt;
&lt;td&gt;VCS, ModelSim&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12. ECO（工程变更）&lt;/td&gt;
&lt;td&gt;在物理设计完成后，对逻辑功能进行修改&lt;/td&gt;
&lt;td&gt;ECO 工具 + 手动 + LEC 校验&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13. GDSII 导出（流片数据）&lt;/td&gt;
&lt;td&gt;生成最终 GDS 文件，提供给 Foundry 进行制造&lt;/td&gt;
&lt;td&gt;Innovus, ICC2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;📦 三、Tape-out 前检查清单&lt;/p&gt;
&lt;p&gt;在正式流片之前，需完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;✅ STA 时序收敛&lt;/li&gt;
&lt;li&gt;✅ DRC 无错误&lt;/li&gt;
&lt;li&gt;✅ LVS 正确&lt;/li&gt;
&lt;li&gt;✅ 功能仿真通过（后仿）&lt;/li&gt;
&lt;li&gt;✅ ERC 电气规则检查&lt;/li&gt;
&lt;li&gt;✅ LEC 等价性检查&lt;/li&gt;
&lt;li&gt;✅ DFM 检查（可制造性分析）&lt;/li&gt;
&lt;li&gt;✅ Sign-off 签核（IR drop, EM, 功耗）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如需我为你输出一份“流程图”或“文档版清单”，也可以告诉我。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="5低功耗设计方法华为海思"&gt;5、低功耗设计方法【华为海思】
&lt;/h3&gt;&lt;p&gt;前端来讲：
（1）采用合适的编码算法&lt;br&gt;
（2）门控时钟&lt;br&gt;
（3）操作数隔离技术&lt;br&gt;
（4）综合中：相位分配，引脚互换，插入缓冲器&lt;br&gt;
（5）多阈值单元，非关键路径上采用高阈值器件，对于关键路径上，采用的是低阈值器件。&lt;br&gt;
后端上来讲：对于设计中翻转频繁的节点，采用低电容金属层布线。尽量缩短翻转率高的线长。采用低功耗为目的时钟树。&lt;br&gt;
（1）静态功耗: a. 在非关键路径用HVT cell； b. power shutfown c. 减少decap cell d. 降温散热；&lt;br&gt;
（2）动态功耗：a. 降压；b. 限制transition time c. 非关键时钟降频；d. 高频信号减少线长；e, 体偏置；f. 非关键路径用HVT Cell；g. MSMV；h. power domain；i. DVFS；j. clock gating；k. power gating&lt;/p&gt;
&lt;h3 id="6芯片的漏电和下面哪些因素有关bcd-大疆"&gt;6、芯片的漏电和下面哪些因素有关（BCD） 【大疆】
&lt;/h3&gt;&lt;p&gt;A 频率 B 电压 C温度 D 工艺&lt;br&gt;
解析：影响漏电流的因素: (1)工艺；(2)电压；(3)温度(温度越高，阈值电压Vth越小)，没有频率(影响动态功耗)&lt;/p&gt;
&lt;h3 id="7以下哪些变化存在功耗消耗abcd-大疆"&gt;7、以下哪些变化存在功耗消耗（ABCD） 【大疆】
&lt;/h3&gt;&lt;p&gt;A只有数据信号翻转 B只有复位信号翻转&lt;br&gt;
C只有时钟信号翻转 D所以信号都不翻转&lt;br&gt;
解析：不翻转也有静态功耗&lt;/p&gt;
&lt;h3 id="8消除噪声的方法-amd"&gt;8、消除噪声的方法 【AMD】
&lt;/h3&gt;&lt;p&gt;消除噪声的方法:&lt;br&gt;
(1) Shielding (2) Deep n-well (3) Isolating a block (4) guard ring&lt;/p&gt;
&lt;h3 id="9设计门电路实现以下波形-联发科"&gt;9、设计门电路实现以下波形。 【联发科】
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/job/assert/image.png"
width="315"
height="80"
srcset="https://sleepman9.github.io/p/job/assert/image_hu_ae61efcb8ce55d63.png 480w, https://sleepman9.github.io/p/job/assert/image_hu_13c3018923b390ef.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="393"
data-flex-basis="945px"
&gt;&lt;br&gt;
&lt;img src="https://sleepman9.github.io/p/job/assert/image-1.png"
width="510"
height="165"
srcset="https://sleepman9.github.io/p/job/assert/image-1_hu_f15641718ea9cc.png 480w, https://sleepman9.github.io/p/job/assert/image-1_hu_a5ee1e6582f780fd.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="309"
data-flex-basis="741px"
&gt;&lt;/p&gt;
&lt;p&gt;解析：先设计一个2分频电路，然后再用clk_in的低电平把二分频的波形过滤一下即可。&lt;/p&gt;
&lt;h3 id="10关于跨时钟域电路的设计以下说法正确的是d-乐鑫提前批"&gt;10、关于跨时钟域电路的设计，以下说法正确的是（D） 【乐鑫提前批】
&lt;/h3&gt;&lt;p&gt;A: 信号经两级D触发器同步后即可进行跨时钟域传递
B: 跨时钟域电路存在亚稳态风险，应当避免使用
C: 跨时钟域电路中一定存在亚稳态
D: 采用单一时钟的电路也可能产生亚稳态
解析：单一时钟不满足setup/hold要求也会出现亚稳态的。&lt;/p&gt;
&lt;h3 id="11nand和nor-flash的主要区别是1nand中常存在坏块-2nand容量可以做到很大3nand写入速度比较快-4nor-flash读出速度比较快-乐鑫提前批"&gt;11、NAND和NOR Flash的主要区别是1.（NAND）中常存在坏块， 2.（NAND）容量可以做到很大，3.（NAND）写入速度比较快， 4.（NOR Flash）读出速度比较快。 【乐鑫提前批】
&lt;/h3&gt;&lt;p&gt;解析：NOR容量小，NAND容量大;NOR读速度快，NAND擦写速度快;NAND会出现坏区&lt;/p&gt;
&lt;h3 id="12可以正常工作的数字电路芯片中一定不存在亚稳态-错-大疆创新"&gt;12、可以正常工作的数字电路芯片中一定不存在亚稳态 (错) 【大疆创新】
&lt;/h3&gt;&lt;p&gt;解析：比如跨时域所用的两级触发器，第一级是会出现亚稳态的，第二级就得到消除。&lt;/p&gt;
&lt;h3 id="13关于网表仿真的描述正确的是d--大疆创新"&gt;13、关于网表仿真的描述正确的是：（D ） 【大疆创新】
&lt;/h3&gt;&lt;p&gt;A 为了保证芯片的正常工作，即使在时间和资源紧张的情况下，也需要将所有RTL仿真用例都进行网表仿真并且确保通过&lt;br&gt;
B 网表仿真的速度比RTL仿真的速度更快&lt;br&gt;
C 网表仿真不能发现实现约束的问题&lt;br&gt;
D 网表仿真可以发现电路设计中的异步问题&lt;br&gt;
解析：网表仿真：通过网表反标标准延时格式文件（SDF）进行仿真，仿真速度较RTL仿真慢，由于标准延时格式文件通过SDC约束和单元逻辑延时和线网延时而来，可以发现约束问题
如果设计的规模较大的话，网表仿真所耗费的时间就比较长（所以B选项错误），所以常采用形式验证手段来保证门级网表在功能上与RTL设计保持一致（所以A选项错误），配合静态时序分析工具保证门级网表的时序。网表仿真中的门级仿真可以发现异步问题（所以D选项正确）。&lt;/p&gt;
&lt;h3 id="14sdf文件在ic哪个阶段使用文件包含了哪些信息-复旦微"&gt;14、SDF文件在IC哪个阶段使用？文件包含了哪些信息？ 【复旦微】
&lt;/h3&gt;&lt;p&gt;答：静态时序分析和后仿真(前仿真是功能仿真，时序为理想；而后仿真包含时序信息，会包含时序验证)。后仿的时候通过反标SDF得到真正的时序信息。
SDF包含了线延时和单元门延时。&lt;/p&gt;
&lt;h3 id="15请解释一下d触发器和latch的区别请解释一下同步复位和异步复位的区别及优缺点-联芸"&gt;15、请解释一下D触发器和latch的区别。请解释一下同步复位和异步复位的区别及优缺点。 【联芸】
&lt;/h3&gt;&lt;p&gt;(1) latch锁存器: 电平触发。当使能信号有效时通路，相反无效时保持输出。容易产生毛刺。门级电路latch消耗的资源少。但是如果在FPGA中，没有latch资源(有D触发器)，因此需要多个LE才能实现。&lt;br&gt;
(2) D触发器：边沿触发。仅在时钟有效沿到来时传递数据。不会产生毛刺。&lt;br&gt;
(3)同步复位：只有在时钟有效沿到来时，复位信号才起作用。优点: a. 有利于仿真器仿真； b. 使电路成为100%的同步时序电路，便于时序分析；c. 过滤毛刺。 缺点: a. 大多数库只有异步DFF，所以需要额外资源搭建同步复位DFF; b. 复位信号的宽度必须大于一个时钟周期。&lt;br&gt;
(4)异步复位：只要有复位信号就能马上复位。优点：a. 节省资源；b. 设计相对简单; 缺点: a. 复位信号易受到毛刺; b. 复位释放的时候容易出现亚稳态问题。&lt;/p&gt;
&lt;h3 id="16已知某种工艺商提供下面四种标准单元库hvt_c30-hvt_c40-lvt_c30-lvt_c40其中hvt表示high-threshold-voltagelvt表示low-threshold-voltagec30和c40表示channel-length数值的大小问哪种器件静态功耗有优势哪种器件的速度有优势-比特大陆"&gt;16、已知某种工艺商提供下面四种标准单元库，HVT_C30, HVT_C40, LVT_C30, LVT_C40，其中HVT表示high threshold voltage，LVT表示low threshold voltage，C30和C40表示channel length数值的大小。问：哪种器件静态功耗有优势？哪种器件的速度有优势？ 【比特大陆】
&lt;/h3&gt;&lt;p&gt;答：HVT_C40静态功耗有优势。因为阈值电压越高，沟道长度越长，漏电流越小。&lt;br&gt;
LVT_C30速度有优势，阈值电压越小，沟道长度越短，饱和电流越高。&lt;/p&gt;
&lt;h3 id="17why-power-stripes-routed-in-the-top-metal-layers"&gt;17.Why power stripes routed in the top metal layers?
&lt;/h3&gt;&lt;p&gt;为什么电源走线选用最上面的金属层？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：1&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;难度指数:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1:常识&amp;ndash;无论是否有工作经验，都应该准确回答&lt;br&gt;
2:简单&amp;ndash;只要做过一点后端的设计，就应该明白&lt;br&gt;
3:一般&amp;ndash;有实际工作经验一年左右，做过2个以上真正的设计，应该可以答上来&lt;br&gt;
4:较难&amp;ndash;在这个特定的领域有较多的研究，并积累了一定的经验&lt;br&gt;
5:很难&amp;ndash;基本上是专家级的牛人了！&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顶层金属层电阻最小，能承载更大电流，IR drop小。&lt;/li&gt;
&lt;li&gt;布线冲突最少，利于形成大面积电源网络,减少寄生电容和串扰。低层利用率较高，用来做power的话会占用一些有用的资源，比如std cell 通常是m1 Pin&lt;/li&gt;
&lt;li&gt;EM能力不一样，一般顶层是低层的2~3倍。更适合电源布线&lt;/li&gt;
&lt;li&gt;减小延迟（拥挤情况下走线长）与热量积累&lt;/li&gt;
&lt;li&gt;穿越多个模块/IP：上层金属能轻松跨越各个 IP block，实现供电覆盖。
反过来，底层的 IP block 通常不能被穿越，空间也更局限&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="18why-do-you-use-alternate-routing-approach-hvhvhv-horizontal-vertical-horizontal-vertical-horizontal-vertical"&gt;18.Why do you use alternate routing approach HVH/VHV (Horizontal-Vertical-Horizontal/ Vertical-Horizontal-Vertical)?
&lt;/h3&gt;&lt;p&gt;为什么要使用横竖交替的走线方式？ （感觉这个问题比较弱智，但是号称是intel的面试问题，晕！我憧憬和向往的圣地啊！！！）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：1&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少串扰（Crosstalk）干扰：交替的方向可以降低相邻金属层之间的电容耦合。如果两个相邻层都是同方向（比如都是水平方向），那么它们之间就容易产生电容耦合，导致信号干扰、延迟增加甚至信号完整性问题&lt;/li&gt;
&lt;li&gt;简化布线规则与提升可路由性，便于使用布线工具自动优化&lt;/li&gt;
&lt;li&gt;配合设计规则检查（DRC）更容易通过&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="19-how-to-fix-x-talk-violation"&gt;19. How to fix x-talk violation？
&lt;/h3&gt;&lt;p&gt;如何解决线间干扰？ (（应该至少有5大类解决办法，wire spacing, shielding, change layer之类的只算其中1类）)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：4&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;upsize victim net driver, downsize aggressor net driver&lt;/li&gt;
&lt;li&gt;increase wire space, shielding, change layer，change wire width&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Increase wire spacing：加大两根线之间的距离，降低寄生电容耦合。&lt;/p&gt;
&lt;p&gt;Shielding：在受害者与攻击者之间加接地/电源线，屏蔽电磁干扰。&lt;/p&gt;
&lt;p&gt;Change layer：换到耦合少的层（如低金属密度、厚介电层的层）。&lt;/p&gt;
&lt;p&gt;Change wire width：增宽导线可降低单位长度上的电阻和提高信号完整性&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;insert butter in victim net&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长线更易受串扰：导线越长，电容和电感耦合越大，串扰越严重&lt;/li&gt;
&lt;li&gt;插入缓冲器（Buffer）相当于将长导线分割成若干段，每段的耦合电容/电感减小，从而降低耦合强度，限制串扰传播范围。&lt;/li&gt;
&lt;li&gt;缓冲器是有源器件，它会重新驱动输出信号。&lt;/li&gt;
&lt;li&gt;上一级网络受到的串扰不会“直接传递”到下一级，因为缓冲器把其&lt;strong&gt;终止在当前级&lt;/strong&gt;，仅把自身输出给后面。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="4"&gt;
&lt;li&gt;把与victim net相连的输入端改成Hi-Vth的单元&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;高阈值电压单元对电压扰动的灵敏度较低，因此能更好地抗串扰；&lt;/p&gt;
&lt;p&gt;特别在输入端使用 Hi-Vth，可增加 noise margin。&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;改变信号的 timing window&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 aggressor 和 victim 的信号切换时序错开（即非重叠的时间窗口），即使存在耦合电容，也不会形成严重干扰&lt;/p&gt;
&lt;h3 id="20-what-would-you-do-in-order-to-not-use-certain-cells-from-the-library"&gt;20. What would you do in order to not use certain cells from the library?
&lt;/h3&gt;&lt;p&gt;如何禁止使用库里面的某些单元？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：1&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;禁用就用set_dont_use&lt;br&gt;
禁止修改就用set_dont_touch&lt;/p&gt;
&lt;h3 id="21-during-the-synthesis-what-type-of-wire-load-model-are-often-used"&gt;21. During the synthesis, what type of wire load model are often used?
&lt;/h3&gt;&lt;p&gt;做RTL综合时，经常使用的wire load model有哪几种？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：2&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在综合时，除了用ZWLM(zero wire load model)[]，或者不同K值的wire load model以外，还有一个基于物理位置（距离）的wire load model，在Cadence的RC中叫PLE，Synopsys叫DC Ultra Topographical&lt;/p&gt;
&lt;p&gt;背景：&lt;br&gt;
在数字电路设计中的 RTL 综合（RTL Synthesis） 过程中，Wire Load Models 用于估计信号传输时的延迟和功耗。这些模型通过将布线对电路的影响考虑进去，帮助综合工具做出合理的时序、面积和功耗优化决策。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;详细解释&lt;/summary&gt;
&lt;ol&gt;
&lt;li&gt;Zero Wire Load Model（ZWLM）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义：此模型假设所有的信号线都具有零的电容和延迟，即没有任何布线带来的电容影响。&lt;/p&gt;
&lt;p&gt;应用场景：通常用于早期设计阶段或当设计工具的目标是尽可能地减少信号的布线延迟影响时。由于这种模型没有考虑到布线电容，它适合用来做快速原型设计，但会导致计算出的时序不准确。&lt;/p&gt;
&lt;p&gt;优缺点：&lt;/p&gt;
&lt;p&gt;优点：计算速度快，适用于初步设计。&lt;/p&gt;
&lt;p&gt;缺点：不真实，因为电路中的布线总会带来一定的延迟和功耗。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;Traditional Wire Load Model（基于K值的WLM）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义：这种模型通过参数 K（通常是电容与信号长度或连接数量的比例）来估算布线电容。综合工具根据设计中的信号连接数量和布局来估算布线的电容和延迟。&lt;/p&gt;
&lt;p&gt;应用场景：适用于那些信号连接相对简单且布线关系较为规则的设计。这种模型假设电容是与布线长度或连接数量线性相关的。&lt;/p&gt;
&lt;p&gt;优缺点：&lt;/p&gt;
&lt;p&gt;优点：计算比较简单，适合一些常见的、规则化的设计。&lt;/p&gt;
&lt;p&gt;缺点：它不能精确考虑电路中复杂的布线结构，尤其是在设计中存在较大物理差异或布局时。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;Topographical Wire Load Model（基于物理位置的WLM）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义：该模型基于电路中的实际物理布局进行建模，考虑了布线的具体物理距离、层次结构和其他布局细节。在 Cadence 中称之为 PLE（Physical Layout Extraction），而在 Synopsys 中称之为 DC Ultra Topographical。&lt;/p&gt;
&lt;p&gt;应用场景：这种模型适用于高精度的设计，尤其是在复杂布局和大规模集成电路中。它能够考虑到每条信号线的具体物理长度、阻抗和电容，提供更为准确的时序分析和功耗估算。&lt;/p&gt;
&lt;p&gt;优缺点：&lt;/p&gt;
&lt;p&gt;优点：提供非常准确的估算，能够反映复杂布局的电容影响。&lt;/p&gt;
&lt;p&gt;缺点：计算开销大，需要更多的资源和时间进行模拟。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;ZWLM：假设没有布线影响，适用于快速估算，适合初步设计阶段。&lt;/p&gt;
&lt;p&gt;基于K值的WLM：适合常见的布线情况，计算简单但不精确。&lt;/p&gt;
&lt;p&gt;Topographical WLM：基于物理布局，最精确，但计算复杂，适用于精密设计和布局。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="22-what-types-of-delay-model-are-used-in-digital-design-数字ic设计中有多少种类型的delay-model"&gt;22. What types of delay model are used in digital design? (数字IC设计中有多少种类型的delay model)
&lt;/h3&gt;&lt;p&gt;答案就是你说的“NLDM，CCS，和ECSM”，还有一个现在基本不用了的&amp;ndash;LDM&lt;/p&gt;
&lt;details&gt;
1. NLDM (Non-Linear Delay Model)
定义：非线性延迟模型（NLDM）考虑了信号传播的非线性特性，尤其是在较大负载或较长布线的情况下。它通过对延迟和电容之间的关系进行非线性拟合来计算延迟。
&lt;p&gt;特点：NLDM 通常用于高精度的延迟建模，特别是在复杂设计中，能够精确描述延迟与电容、负载的非线性关系。&lt;/p&gt;
&lt;p&gt;应用场景：适用于需要更高精度时序估算的复杂电路，特别是当负载较大或信号传播路径较长时。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;CCS (Constant Current Source Model)
定义：恒定电流源模型（CCS）假设每个门电路的驱动能力是常数，且与输入电压变化无关。CCS 延迟模型以恒定的电流源来描述门电路的电流驱动特性，并根据负载电容来计算延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：这种模型通过一个简化的电流源模型来估算门电路的延迟，适用于一些简单设计中的时序计算。&lt;/p&gt;
&lt;p&gt;应用场景：适用于电流驱动能力较为稳定、较简单的电路。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;ECSM (Elmore Delay Model)
定义：Elmore 延迟模型（ECSM）是一种基于 RC 网络的经典延迟模型，通过对电路中的电阻和电容进行加权计算，给出信号传播延迟的估算值。它通过 RC 等效电路分析信号的传输延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：ECSM 以 RC 网络的等效模型来计算延迟，比较简单并且计算速度较快，适用于较为规则的电路。&lt;/p&gt;
&lt;p&gt;应用场景：适用于大部分常规的数字电路设计，尤其在布线延迟较为均匀时使用广泛。&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;LDM (Linear Delay Model) — 已不常用
定义：线性延迟模型（LDM）假设延迟与电容之间的关系是线性的，即延迟与电容成正比。LDM 是最早期的延迟模型之一，已逐渐被更精确的模型所取代。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：LDM 模型计算简单，但没有考虑非线性效应，适用于非常简单的设计或不需要高精度估算的场合。&lt;/p&gt;
&lt;p&gt;应用场景：由于其简化的假设，现在几乎不再使用，特别是在现代复杂的数字设计中。&lt;/p&gt;
&lt;p&gt;总结：
NLDM：精确的非线性延迟模型，适用于复杂电路和高精度要求的设计。&lt;/p&gt;
&lt;p&gt;CCS：基于恒定电流源的模型，适用于简单设计和较为稳定的驱动能力。&lt;/p&gt;
&lt;p&gt;ECSM：基于 RC 网络的经典延迟模型，计算速度快，适用于大多数标准数字电路。&lt;/p&gt;
&lt;p&gt;LDM：已不常用，线性假设使得其在现代设计中精度不够。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;Wire Load Model (WLM) 和 Delay Model 都是数字设计中用于评估时序、延迟和功耗的工具，但它们有不同的关注点和计算方式。它们之间有一定的关系，但也有各自独立的作用。&lt;br&gt;
WLM 主要关注的是布线的电容特性，而 Delay Model 则更侧重于逻辑元件的延迟。它们相辅相成，WLM 提供了 Delay Model 需要的输入，而 Delay Model 通过这些输入来计算信号传播的延迟。&lt;/p&gt;
&lt;h3 id="23-how-delays-are-characterized-using-wlm-wire-load-model"&gt;23. How delays are characterized using WLM (Wire Load Model)?
&lt;/h3&gt;&lt;p&gt;使用一般的WLM （不是zero WLM，也不是按照物理位置算的DCT），DC是如何计算delay的？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：2&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;一条Timing path上的Delay有2部分组成，Cell Delay + NetDelay。&lt;br&gt;
在ＤＣ中，Net Delay应该来说就是有ＷＬＭ中得到的，而Cell Delay就是根据WLM中得到的input Tran跟Cell 的output load通过查表得到Cell delay。&lt;/p&gt;
&lt;p&gt;既然问的是如何使用WLM来计算延迟，那一定是net delay了，其实这是一个小坑，看你知道不知道WLM是用来计算什么的延迟。&lt;/p&gt;
&lt;p&gt;现在问题变得直接了，就是考你WLM的具体用法&amp;ndash;如何计算出net的R和C的？&lt;/p&gt;
&lt;p&gt;DC在计算延时的时候，主要根据输出的tansition 和net的RC值来计算。&lt;br&gt;
output tansition是由驱动cell的input tansition和load通过查表得到的&lt;br&gt;
而net的rc就要根据所选取的wrie load model来计算，计算时和输出的fanout决定&lt;/p&gt;
&lt;p&gt;以smic13的smic13_wl10为例
wire_load(&amp;ldquo;smic13_wl10&amp;rdquo;) {
resistance : 8.5e-8;
capacitance : 1.5e-4;
area : 0.7;
slope : 66.667;
fanout_length (1,66.667);}
根据fanout值，由fanout(1,66.667)可以得出互连线长度为66.667，然后根据resistance和capacitance计算出互连线电容为1.5e-4&lt;em&gt;66.667，互连线电阻为8.5e-8&lt;/em&gt;66.667
，当然如果扇出值表中没有，就会用到slope，例如扇出为3时，此时估算的互连线长度为1*66.667+（3-1）*slope，再计算出RC值，然后DC由此计算net的延时&lt;/p&gt;
&lt;h3 id="24there-are-source-clock-clka-create_clock-and-generated-clock-clkb-by-clka"&gt;24.There are source clock clka (create_clock), and generated clock clkb by clka.
&lt;/h3&gt;&lt;p&gt;In pre-CTS netlist, there is network latency in clka, how this latency propagates to clkb?
In post-CTS netlist, What you need to do for this network latency?&lt;/p&gt;
&lt;p&gt;假设有两个时钟，原始为clka，生成的时钟为clkb，
在没有时钟树的网表中，clka的network latency会自动传递到clkb上吗？clkb的latency如何描述？&lt;br&gt;
在生成时钟树的网表中，如何处理network latency? clkb的latency又如何描述？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：3&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;A：&lt;br&gt;
1）latency会自动传到clkb上&lt;br&gt;
2）去掉clock network latency，让工具自己算&lt;/p&gt;
&lt;h3 id="25there-are-source-clock-clka-create_clock-and-generated-clock-clkb-by-clka-how-do-you-specify-them-in-cts-spec-file-assume-there-is-real-timing-path-between-clka-and-clkb"&gt;25.There are source clock clka (create_clock), and generated clock clkb by clka. how do you specify them in CTS spec file? Assume there is real timing path between clka and clkb.
&lt;/h3&gt;&lt;p&gt;clkb是clka的生成时钟，在CTS的spec文件中如何定义这两个时钟？假设clka和clkb之间的FF有时序收敛的要求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：3&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在CTS的spec文件中定义 clka 是 root，clkb 为 through pin，再加上那些应该有的skew，transition，insertion delay等就好了，
其它的事CTS会给你做&lt;/p&gt;
&lt;h3 id="26"&gt;26.
&lt;/h3&gt;</description></item><item><title>IC验证——UVM方法学</title><link>https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/</link><pubDate>Mon, 28 Jul 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/</guid><description>&lt;img src="https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/cover.png" alt="Featured image of post IC验证——UVM方法学" /&gt;&lt;h2 id="前言"&gt;前言
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;验证的本质：尽可能的找出设计的bug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证的3要素
(1)灌激励：输入信号
(2)集响应：输出信号
(3)作比较：比较&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="uvm实战张强"&gt;《uvm实战》&amp;ndash;张强
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/image.png"
width="1277"
height="652"
srcset="https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/image_hu_486d6b03ae9580d9.png 480w, https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/image_hu_51186de42492e7a7.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="195"
data-flex-basis="470px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_41034231/article/details/108130501" target="_blank" rel="noopener"
&gt;UVM验证平台整体结构&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="基础介绍相关link"&gt;基础介绍相关link
&lt;/h2&gt;&lt;h2 id="books"&gt;Books
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://github.com/obugss/ebook" target="_blank" rel="noopener"
&gt;验证书籍&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ASIC全流程</title><link>https://sleepman9.github.io/p/asic%E5%85%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Sun, 20 Jul 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/asic%E5%85%A8%E6%B5%81%E7%A8%8B/</guid><description>&lt;img src="https://sleepman9.github.io/p/asic%E5%85%A8%E6%B5%81%E7%A8%8B/cover.png" alt="Featured image of post ASIC全流程" /&gt;&lt;h2 id="ic全流程"&gt;ic全流程
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;规格制定。频率，功耗，速度&lt;/li&gt;
&lt;li&gt;RTL设计。HDL描述逻辑Algorithm，类似于高级设计语言cpp，里面涉及低功耗设计方法&lt;/li&gt;
&lt;li&gt;功能仿真。逻辑代码是否正确，查看波形&lt;/li&gt;
&lt;li&gt;逻辑综合。将RTL代码转化为门级网表，里面包含时序约束，功耗约束，PPA优化&lt;/li&gt;
&lt;li&gt;STA。确保时钟⏰&lt;/li&gt;
&lt;li&gt;形式验证。比较RTL 代码逻辑功能是否和逻辑综合出来的门级网表功能一致&lt;/li&gt;
&lt;li&gt;门级仿真。&lt;/li&gt;
&lt;li&gt;DFT。在设计中加入测试结构，使芯片在生产后可以验证其功能正确性&lt;/li&gt;
&lt;li&gt;Floorplan&lt;/li&gt;
&lt;li&gt;place&lt;/li&gt;
&lt;li&gt;CTS&lt;/li&gt;
&lt;li&gt;route&lt;/li&gt;
&lt;li&gt;STA&lt;/li&gt;
&lt;li&gt;PI&lt;/li&gt;
&lt;li&gt;SI&lt;/li&gt;
&lt;li&gt;Low Power&lt;/li&gt;
&lt;li&gt;Signoff&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>网表相关</title><link>https://sleepman9.github.io/p/%E7%BD%91%E8%A1%A8%E7%9B%B8%E5%85%B3/</link><pubDate>Thu, 10 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E7%BD%91%E8%A1%A8%E7%9B%B8%E5%85%B3/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E7%BD%91%E8%A1%A8%E7%9B%B8%E5%85%B3/cover.png" alt="Featured image of post 网表相关" /&gt;&lt;h2 id="hspice-quick-reference-guide"&gt;HSPICE Quick Reference Guide
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://amarketplaceofideas.com/wp-content/uploads/2014/09/hspice_qr1.pdf" target="_blank" rel="noopener"
&gt;HSPICE Quick Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://iccircle.com/static/upload/img20240809173315.pdf" target="_blank" rel="noopener"
&gt;HSPICE® User Guide: Basic Simulation and Analysis&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="网表求解的本质"&gt;网表求解的本质
&lt;/h2&gt;&lt;p&gt;网表求解的本质在于将电路中各个元件和它们的连接关系转化为数学方程（通常基于基尔霍夫定律和元件的本构关系），然后利用数值计算方法求解这些方程组，从而得到各个节点电压和支路电流等信息。简单来说，就是把电路“翻译”成数学问题，再使用求解器进行数值求解。&lt;/p&gt;
&lt;h2 id="不同仿真类型的的本质"&gt;不同仿真类型的的本质
&lt;/h2&gt;&lt;p&gt;不同仿真类型的本质都在于：将电路的物理行为转化为数学模型，然后求解相应的数学方程以获得电路在特定条件下的响应。不过，它们侧重关注的方面不同，具体说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直流工作点分析 (.op) 和直流扫描分析 (.DC)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直流工作点分析：求解电路在直流稳态下（没有时间变化因素）的电压、电流等参数。它的本质是求解一组非线性代数方程，确定电路各节点的静态工作状态。&lt;/p&gt;
&lt;p&gt;直流扫描分析：在直流工作点分析的基础上，通过改变一个或多个直流激励源（如电压或电流），观察器件或电路参数随偏置变化的趋势。其本质依然是求解静态非线性代数方程，但需要遍历一系列激励值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;瞬态分析 (.TRAN)
瞬态分析关注电路响应随时间的动态变化。它将电路描述为一组微分方程（可能还包含非线性部分），然后利用数值积分算法（如欧拉法、龙格-库塔法等）求解时间域响应，从而揭示电路在施加激励后随时间变化的动态行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交流小信号分析 (.AC)
该分析是在电路的直流工作点附近对电路进行线性化，转换到频率域求解。它的本质是将电路的非线性行为在小激励条件下近似为线性模型，通过求解复数域中的方程（使用如拉普拉斯变换或者直接建立导纳矩阵）得到电路的频率响应、相位特性等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之，无论是哪种仿真类型，基本思路都是“建立数学模型 – 数值求解 – 得到物理量”，只是不同的仿真关注于电路静态状态、动态响应或频率特性等不同方面。&lt;/p&gt;</description></item><item><title>一些芯片设计的冷知识</title><link>https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/</link><pubDate>Wed, 02 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/cover.png" alt="Featured image of post 一些芯片设计的冷知识" /&gt;&lt;h2 id="原理图-芯片物理版图"&gt;原理图-&amp;gt;芯片物理版图
&lt;/h2&gt;&lt;p&gt;根据电路设计图（也称为原理图或HDL代码）生成芯片物理版图&lt;/p&gt;
&lt;h3 id="逻辑综合"&gt;逻辑综合
&lt;/h3&gt;&lt;p&gt;这是将电路设计图转换为门级网表的过程，门级网表是由基本逻辑门（如与门、或门、非门等）和触发器（如D触发器、JK触发器等）组成的电路结构，它可以反映电路设计图的功能和性能。逻辑综合需要设定约束条件，就是希望综合出来的电路在面积、时序等目标参数上达到的标准；逻辑综合还需要指定基于的库，使用不同的综合库，在时序和面积上会有差异。常用的逻辑综合工具有Synopsys的Design Compiler，Cadence的PKS，Synplicity的Synplify等。&lt;/p&gt;
&lt;h3 id="布局规划"&gt;布局规划
&lt;/h3&gt;&lt;p&gt;这是在确定芯片的总体尺寸和形状后，将芯片中的各个模块（如IP核、存储器、I/O引脚等）分配到合适的位置的过程，布局规划需要考虑各个模块之间的连接关系、信号延迟、功耗分布、热效应等因素，以优化芯片的性能和可靠性。布局规划后，芯片的大小，Core的面积，Row的形式、电源及地线的Ring和Strip都确定下来了。常用的布局规划工具有Cadence的Encounter/Innovus，Synopsys的ICC等。&lt;/p&gt;
&lt;h3 id="时钟树综合"&gt;时钟树综合
&lt;/h3&gt;&lt;p&gt;这是在布局规划后，对芯片中的时钟信号进行专门的布线设计的过程，时钟信号在数字芯片中起着全局指挥作用，它需要对称地分配到各个寄存器单元，以保证时钟从同一个时钟源到达各个寄存器时，时钟延迟差异最小。时钟树综合需要考虑时钟频率、抖动、偏移等因素，以提高芯片的时序性能。常用的时钟树综合工具有Cadence Encounter/Innovus, Synopsys ICC, Synopsys PrimeTime SI等。&lt;/p&gt;
&lt;h3 id="布局布线"&gt;布局布线
&lt;/h3&gt;&lt;p&gt;这是将门级网表转换为具体的物理版图的过程，包括标准单元（如基本逻辑门电路）的放置和各种层之间的走线。布局布线需要遵循特定工艺的设计规则（如最小宽度、最小间距等），以保证版图可以被正确地加工出来。布局布线还需要考虑面积、功耗、时序、噪声、串扰等因素，以优化芯片的质量和效率。常用的布局布线工具有Cadence Encounter/Innovus, Synopsys ICC, Synopsys Astro等。&lt;/p&gt;
&lt;h3 id="物理验证"&gt;物理验证
&lt;/h3&gt;&lt;p&gt;这是在完成物理版图后，对其进行检查和修正的过程&lt;/p&gt;
&lt;h4 id="设计规则检查drc"&gt;设计规则检查（DRC）
&lt;/h4&gt;&lt;p&gt;这是检查物理版图是否符合工艺设计规则的过程，如果发现任何违反规则的地方，就需要进行修改。常用的设计规则检查工具有Synopsys的Hercules/ICV，Cadence的Assura/PVS，Mentor的Calibre等。&lt;/p&gt;
&lt;h4 id="布局与网表比较lvs"&gt;布局与网表比较（LVS）
&lt;/h4&gt;&lt;p&gt;这是检查物理版图是否与门级网表在功能上完全一致的过程，如果发现任何不匹配或缺失的地方，就需要进行调整。常用的布局与网表比较工具有Synopsys的Hercules/ICV，Cadence的Assura/PVS，Mentor的Calibre等。&lt;/p&gt;
&lt;h4 id="寄生参数提取pex"&gt;寄生参数提取（PEX）
&lt;/h4&gt;&lt;p&gt;这是从物理版图中提取出电阻、电容、电感等寄生参数的过程，这些参数会影响电路的性能和信号完整性，需要进行后仿真和分析。常用的寄生参数提取工具有Synopsys的Star-RC, Cadence的QRC, Mentor的Calibre XRC等。&lt;/p&gt;
&lt;h4 id="时序验证sta"&gt;时序验证（STA）
&lt;/h4&gt;&lt;p&gt;这是基于寄生参数提取的结果，对电路的时序性能进行验证的过程，主要检查电路是否存在建立时间（setup time）和保持时间（hold time）的违例，如果发现任何时序问题，就需要进行优化。常用的时序验证工具有Synopsys的PrimeTime, Cadence’s Tempus等。&lt;/p&gt;
&lt;h4 id="信号完整性分析si"&gt;信号完整性分析（SI）
&lt;/h4&gt;&lt;p&gt;这是基于寄生参数提取的结果，对电路的信号质量进行分析的过程，主要检查电路是否存在噪声、串扰、反射等问题，如果发现任何信号完整性问题，就需要进行改善。常用的信号完整性分析工具有Synopsys PrimeTime SI, Cadence Sigrity, Ansys Totem/Redhawk等。&lt;/p&gt;
&lt;p&gt;物理版图验证完成后，就可以将GDSII文件交给芯片代工厂（称为Foundry），在晶圆硅片上通过多道工艺步骤（如光刻、刻蚀、离子注入、沉积等）实现芯片的制造，再进行封装和测试，就得到了我们实际看见的芯片。&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/Jailman/article/details/132761728" target="_blank" rel="noopener"
&gt;一些芯片设计的冷知识&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="芯片键合bonding"&gt;芯片键合（bonding）
&lt;/h2&gt;&lt;p&gt;这个博主的其他文章也值得一看《傻白入门芯片设计系列》&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_46675545/article/details/128050411" target="_blank" rel="noopener"
&gt;傻白入门芯片设计，芯片键合(Die Bonding)（四）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_46675545/article/details/128053478" target="_blank" rel="noopener"
&gt;傻白入门芯片设计，典型的2D/2D+/2.5D/3D封装技术（六）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_46675545/article/details/128076797" target="_blank" rel="noopener"
&gt;傻白入门芯片设计，如何降低CPU功耗？（八）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="为什么还需要interposer层级"&gt;为什么还需要interposer层级
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;bump的大小是否符合和芯片I/O要求&lt;/li&gt;
&lt;li&gt;bump影响寄生参数值（根据电阻电感电容的公式推理即可. [Bump 越大，寄生电阻和寄生电感越小，但寄生电容越大。]&lt;/li&gt;
&lt;li&gt;更加灵活的互联（更短的互联路径）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="4d芯片集成"&gt;4D芯片集成
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://www.eet-china.com/mp/a352641.html" target="_blank" rel="noopener"
&gt;芯片的先进封装会发展到4D吗？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="dram预充电的作用"&gt;DRAM预充电的作用
&lt;/h2&gt;&lt;p&gt;预充电操作是为了“清空现场、重置电压”，以便 DRAM 可以正确执行下一次读写操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DRAM 的位线是差分信号线，感应放大器是通过对微小电压差放大来判断是 0 还是 1 的。如果前一次操作后电压还残留，就会影响下一次数据的正确性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;预充电 = 把位线电压“归一化”到 ½ 电压，为下次判别提供基准。不偏向 0，也不偏向 1&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;cell 电容&lt;/th&gt;
&lt;th&gt;位线电压&lt;/th&gt;
&lt;th&gt;连接后&lt;/th&gt;
&lt;th&gt;差值&lt;/th&gt;
&lt;th&gt;放大结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;存1&lt;/td&gt;
&lt;td&gt;Vdd&lt;/td&gt;
&lt;td&gt;Vdd/2&lt;/td&gt;
&lt;td&gt;位线稍↑&lt;/td&gt;
&lt;td&gt;+ΔV&lt;/td&gt;
&lt;td&gt;判为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存0&lt;/td&gt;
&lt;td&gt;0V&lt;/td&gt;
&lt;td&gt;Vdd/2&lt;/td&gt;
&lt;td&gt;位线稍↓&lt;/td&gt;
&lt;td&gt;-ΔV&lt;/td&gt;
&lt;td&gt;判为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;也就是说，cell 的电压通过连接到“Vdd/2”的位线上，形成一个微小的正/负波动，这时 Sense Amplifier 就可以把这个波动“放大”成逻辑 1 或 0。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;感应放大器只对微小差异敏感。若位线未被预充电，数据对比将发生偏移，导致：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据判别错误（读取出错）&lt;/p&gt;
&lt;p&gt;写入扰动（错误写入别的单元）&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_46675545/article/details/128210207" target="_blank" rel="noopener"
&gt;傻白入门芯片设计，史上最最最全DRAM介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/Tranquil_ovo/article/details/129876980" target="_blank" rel="noopener"
&gt;【DC】逻辑综合基础&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="lc谐振"&gt;LC谐振
&lt;/h2&gt;&lt;p&gt;电容，电感，反复充放电。
&lt;a class="link" href="https://zhuanlan.zhihu.com/p/532163425" target="_blank" rel="noopener"
&gt;还搞不懂 LC振荡电路原理？看这一文就够了，图文结合，立马带你搞定&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="正片和负片"&gt;正片和负片
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/weixin_42837669/article/details/110411765" target="_blank" rel="noopener"
&gt;PCB正片和负片的区别与使用&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="allegro加密文件密码破解和解除读写导出限制"&gt;Allegro加密文件密码破解和解除读写导出限制
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/vanfone/article/details/116275609" target="_blank" rel="noopener"
&gt;Allegro加密文件密码破解和解除读写导出限制&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="静态时序分析sta报告摘要"&gt;静态时序分析（STA）报告摘要
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image.png"
width="777"
height="368"
srcset="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image_hu_597ce37bf5508b64.png 480w, https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image_hu_3060480dc45bbc6.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="506px"
&gt;&lt;/p&gt;
&lt;p&gt;这张图展示的是数字后端设计中关键的 &lt;strong&gt;静态时序分析（STA）报告摘要&lt;/strong&gt; 和 &lt;strong&gt;设计规则违规（DRV）检查统计&lt;/strong&gt;，以下是详细解读：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="1-setup-mode-时序分析表"&gt;📍&lt;strong&gt;1. Setup Mode 时序分析表&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这部分列出了多种 &lt;strong&gt;路径类别（setup mode）&lt;/strong&gt; 的时序结果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WNS (ns)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Worst Negative Slack，最差路径的负裕量（最坏延迟）&lt;/td&gt;
&lt;td&gt;- 值为负数时说明时序违例。&lt;br&gt;- &lt;code&gt;all&lt;/code&gt; 模式下为 &lt;code&gt;-0.002ns&lt;/code&gt;，说明有轻微的时序违例。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TNS (ns)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Total Negative Slack，总的时序违例之和&lt;/td&gt;
&lt;td&gt;所有违反路径加总的延迟量。&lt;code&gt;-0.003ns&lt;/code&gt; 是非常轻微的问题。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Violating Paths&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;时序违例路径数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;all&lt;/code&gt; 模式下有 2 条路径违例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;All Paths&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;总路径数&lt;/td&gt;
&lt;td&gt;全设计共 12,273 条路径（时序分析覆盖）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;🔍 各模式说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;reg2reg&lt;/code&gt;: 从寄存器到寄存器的路径（主路径）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reg2cgate&lt;/code&gt;: 从寄存器到组合逻辑门（用于分析组合部分）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;: 默认路径类别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt;: 总体视角&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="2-drvsdesign-rule-violations-设计规则违规统计"&gt;📍&lt;strong&gt;2. DRVs：Design Rule Violations 设计规则违规统计&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这一部分列出的是违反电气规则（例如上限/转换时间等）的信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DRV 类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;结果解读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_cap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大负载电容违例&lt;/td&gt;
&lt;td&gt;共检测到 8 条网络超出上限（8 个实例），但&lt;strong&gt;没有真实违例值&lt;/strong&gt;（Worst Vio = 0），可能已修复。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_tran&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大信号转换时间违例&lt;/td&gt;
&lt;td&gt;检测到 6 条网络；Worst Vio 为 0.000，说明也已修复。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_fanout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大扇出&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_length&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大线长&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;📝 注：Real vs Total 表示是否是“实际有效违规”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Real：当前设计中真实存在的；&lt;/li&gt;
&lt;li&gt;Total：工具设置阈值检测到的超限数（可能已修复或忽略）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="3-density--routing-overflow"&gt;📍&lt;strong&gt;3. Density &amp;amp; Routing Overflow&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Density&lt;/strong&gt;: &lt;code&gt;46.432%&lt;/code&gt;
→ 标准单元填充密度，不高，布线空间充足。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Routing Overflow&lt;/strong&gt;: &lt;code&gt;0.00% H and 0.00% V&lt;/code&gt;
→ 布线拥塞情况非常理想，无水平或垂直溢出，说明布线非常顺畅。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="-总结"&gt;✅ 总结
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;结论&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;时序（STA）&lt;/td&gt;
&lt;td&gt;有轻微负 slack（-0.003ns），可继续优化，未严重超时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设计规则（DRV）&lt;/td&gt;
&lt;td&gt;所有电气规则违例已修复，0 违规&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;布局密度&lt;/td&gt;
&lt;td&gt;46%，空间富余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;布线拥塞&lt;/td&gt;
&lt;td&gt;0%，极佳&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;如你需要，我可以提供一些优化建议来消除 WNS/TNS。是否需要我帮你写个时序优化建议脚本或时序debug checklist？&lt;/p&gt;
&lt;h2 id="spef文件"&gt;SPEF文件
&lt;/h2&gt;&lt;p&gt;SPEF（Standard Parasitic Exchange Format）文件是一种 标准电路寄生参数交换文件，用于描述芯片设计中 电路的寄生参数信息，如：&lt;/p&gt;
&lt;p&gt;寄生电容（capacitance）&lt;/p&gt;
&lt;p&gt;寄生电阻（resistance）&lt;/p&gt;
&lt;p&gt;电感（如有）&lt;/p&gt;
&lt;p&gt;这些寄生参数主要来自于布线和互连，会影响信号延迟和电路时序，是时序分析（STA）和信号完整性分析（SI）不可或缺的数据源。&lt;/p&gt;
&lt;h2 id="cs中的前后端和ic中的前后端区别"&gt;CS中的前后端和IC中的前后端区别
&lt;/h2&gt;&lt;p&gt;这是个非常好的问题，很多初学者都会混淆“前端/后端”在 &lt;strong&gt;计算机科学（CS）&lt;/strong&gt; 和 &lt;strong&gt;数字IC设计&lt;/strong&gt; 这两个领域中的含义。以下是详细对比说明：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-一计算机科学cs中的前端与后端"&gt;🧠 一、&lt;strong&gt;计算机科学（CS）中的前端与后端&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这是你在 Web 开发、软件工程等方向常听到的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;维度&lt;/th&gt;
&lt;th&gt;前端（Frontend）&lt;/th&gt;
&lt;th&gt;后端（Backend）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;定义&lt;/td&gt;
&lt;td&gt;用户直接交互的部分&lt;/td&gt;
&lt;td&gt;处理逻辑、数据库、服务器的部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内容&lt;/td&gt;
&lt;td&gt;HTML、CSS、JavaScript、React、Vue 等&lt;/td&gt;
&lt;td&gt;Java、Python、Node.js、数据库、API、服务器逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;示例&lt;/td&gt;
&lt;td&gt;页面按钮、表单、界面动画&lt;/td&gt;
&lt;td&gt;用户登录验证、数据存取、接口开发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;技能栈&lt;/td&gt;
&lt;td&gt;Web UI、响应式设计、DOM 操作&lt;/td&gt;
&lt;td&gt;API 设计、数据库设计、系统架构、权限控制&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;✅ &lt;strong&gt;本质：前端关注“用户体验”，后端关注“数据与逻辑处理”。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-二数字ic设计中的前端与后端"&gt;🔧 二、&lt;strong&gt;数字IC设计中的前端与后端&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这是在芯片设计（如 SoC、CPU）中使用的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;维度&lt;/th&gt;
&lt;th&gt;前端设计（Frontend Design）&lt;/th&gt;
&lt;th&gt;后端设计（Backend Design）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;定义&lt;/td&gt;
&lt;td&gt;描述电路功能逻辑&lt;/td&gt;
&lt;td&gt;实现功能的物理版图布局&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内容&lt;/td&gt;
&lt;td&gt;RTL 编写（Verilog/VHDL）、仿真、综合、形式验证&lt;/td&gt;
&lt;td&gt;布图布局（place &amp;amp; route）、时序收敛、DRC/LVS、RC提取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;工具&lt;/td&gt;
&lt;td&gt;ModelSim, VCS, DC（Design Compiler）等&lt;/td&gt;
&lt;td&gt;Innovus, ICC2, Calibre, StarRC 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;阶段&lt;/td&gt;
&lt;td&gt;- RTL Coding&lt;br&gt;- Functional Simulation&lt;br&gt;- Synthesis&lt;/td&gt;
&lt;td&gt;- Floorplan&lt;br&gt;- Placement&lt;br&gt;- CTS&lt;br&gt;- Routing&lt;br&gt;- DRC/LVS&lt;br&gt;- GDSII 生成&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;✅ &lt;strong&gt;本质：前端构建“逻辑电路”，后端实现“物理电路”。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-总结对比cs-vs-数字ic"&gt;🧩 总结对比：CS vs 数字IC
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;维度&lt;/th&gt;
&lt;th&gt;CS领域&lt;/th&gt;
&lt;th&gt;数字IC设计&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;前端&lt;/td&gt;
&lt;td&gt;用户界面、网页端&lt;/td&gt;
&lt;td&gt;RTL/功能设计&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;后端&lt;/td&gt;
&lt;td&gt;数据逻辑、服务器&lt;/td&gt;
&lt;td&gt;物理实现、布图布线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;工具语言&lt;/td&gt;
&lt;td&gt;JS, HTML, Python, Java&lt;/td&gt;
&lt;td&gt;Verilog, VHDL, Tcl, EDA工具&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="反相器版图"&gt;反相器版图
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-1.png"
width="748"
height="349"
srcset="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-1_hu_88ed76e88ea28ac7.png 480w, https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-1_hu_666f45b0143e3d2c.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="514px"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PMOS 的构造回顾&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PMOS 是放在 n-well 里的。&lt;/p&gt;
&lt;p&gt;它的源极和漏极是 p+ 掺杂区，栅是多晶硅，衬底是 n-well。&lt;/p&gt;
&lt;p&gt;要保证管子正常工作，n-well 必须接到高电位（VDD），防止 n-well 与源/漏之间形成寄生二极管导通。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;为什么要有 N+ 区&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 n-well 里放一个 N+ 区 并连接 VDD，是为了给 n-well 提供欧姆接触。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当金属和半导体直接接触时，会根据 功函数差和半导体掺杂浓度的不同，形成两种接触：&lt;/p&gt;
&lt;p&gt;肖特基接触 (Schottky Contact)：表现为整流特性，电阻较大。&lt;/p&gt;
&lt;p&gt;欧姆接触 (Ohmic Contact)：表现为线性 I–V 特性，电阻小。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;n-well/p-well 本身掺杂浓度比源/漏浅扩散区低很多，即使叫 “高掺杂”，跟源漏的 LDD 或深 N+ 仍然有差距。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;如果金属直接接在 well 上，不加一层高掺杂的 N+ (或 P+) 接触 implant，电阻会比较大。&lt;/p&gt;
&lt;p&gt;单纯的 n-well 是高掺杂 n 型，但与金属直接接触电阻很大。&lt;/p&gt;
&lt;p&gt;通过在 n-well 上打一个 N+ 接触区 (N+ diffusion)，电阻显著降低，形成良好的接触。&lt;/p&gt;
&lt;p&gt;这个 N+ 区并不是 PMOS 的源/漏区，它的作用是把 n-well 本身牢固地连到 VDD，称为 well tie 或 well contact。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;电气意义&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果不把 n-well 固定到 VDD，n-well 电位可能会“漂浮”，会产生 阈值电压漂移、漏电流增加甚至 latch-up 问题。&lt;/p&gt;
&lt;p&gt;N+ 区和金属接触到 VDD，就是为了固定住 n-well 电位。&lt;/p&gt;</description></item><item><title>手机SOC基础</title><link>https://sleepman9.github.io/p/%E6%89%8B%E6%9C%BAsoc%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 31 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E6%89%8B%E6%9C%BAsoc%E5%9F%BA%E7%A1%80/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E6%89%8B%E6%9C%BAsoc%E5%9F%BA%E7%A1%80/cover.png" alt="Featured image of post 手机SOC基础" /&gt;&lt;h2 id="手机soc包含的组件"&gt;手机SOC包含的组件
&lt;/h2&gt;&lt;h3 id="cpu"&gt;CPU：
&lt;/h3&gt;&lt;p&gt;在SOC里面，CPU的面积其实很小，但是它却很重要。ARM是一家英国的芯片设计公司，但是呢，它卖的不是芯片，而是芯片的授权。只有经过它授权，才能生产ARM架构的处理器。那么为什么主流的SOC都必须用ARM呢？在漫长的历史演变中，手机SOC也使用过其它架构，比如X86（PC端的处理器架构），但是都因为性能和功耗不理想，被淘汰了。&lt;/p&gt;
&lt;p&gt;ARM授权的同时，也给了一套公版内核方案，领到授权的芯片设计厂商，可以对公版内核进行大修改，也可以照搬。打个比方，ARM是一个生产熟食的厨师，各大芯片厂商（主妇们）可以将食物买回去直接吃，也可以对食物进行二次加工，让它变得更好吃。目前有“二次加工”能力的主要有苹果、高通、三星，海思在麒麟980上也迈出了第一步，其上所用A76内核有些修改。&lt;/p&gt;
&lt;p&gt;之前我也发布过一篇推文，讲美国将华为列入“实体名单”之后，华为不能使用新的架构，只能在现有ARMv8架构指令集（已经永久授权给了海思）的基础上进行魔改。而这个ARMv8架构，已经用了整整7年，这期间所有的内核都是基于它设计的，等于说先有架构，再有内核，一个架构可以衍生出多种内核。虽然这7年间由于工艺和设计水平的进步，手机CPU性能翻了很多倍，但是毕竟这么久了，也面临着换代，因此这才是华为“最大的危机”。&lt;/p&gt;
&lt;p&gt;现在的手机CPU普遍采用“大小核”的设计，不同内核组合起来。这里的“大小”是指芯片的大小，芯片面积越大，堆的晶体管越多，性能越强。打个比方，就像拉一车人去打架，你车越大，装的人越多，战斗力就越强，但是如果SOC全部都是大核，电池顶不住啊。以麒麟980为例，它采用2个A76大核，2个A76中核，4个A55小核的设计，根据不同的应用来决定开什么核，还是全部开，不同芯片设计厂商的调度不同，性能发挥也有差异。所以，手机CPU绝对不是核心数越多越好的，芯片厂商的设计至关重要。&lt;/p&gt;
&lt;h3 id="gpu"&gt;GPU
&lt;/h3&gt;&lt;p&gt;GPU全称是“图形处理器”，如字面含义，它负责处理图形数据，并向显示屏输送图形的任务，而智能手机上的SOC也要处理各种各样复杂的数据，因此也需要一个强大的GPU。ARM自己也有提供GPU方案，就是大名鼎鼎的Mali系列，这是目前较为主流的一种GPU，而高通则是自家的Adreno系列（其实跟AMD有很深的渊源）。&lt;/p&gt;
&lt;h3 id="npu"&gt;NPU
&lt;/h3&gt;&lt;p&gt;这可以说是最近两年的手机SOC才出现的新的芯片种类，它的全称叫neural-network process units，翻译成中文叫“嵌入式神经网络处理器”。这个名字听起来很高端，简单来说，它主要负责处理涉及神经网络算法和机器学习的海量数据，因为神经网络算法及机器学习需要处理大量信息，而当下的 CPU / GPU 都无法达到如此高效的处理能力，需要一个独立的处理芯片来做这个事，才有NPU的诞生。现在的“人工智能”AI的概念可以说非常火热，而NPU就是让手机变得更智能、更聪明的必要条件。&lt;/p&gt;
&lt;p&gt;目前，苹果A系列和海思麒麟系列都有独立的NPU，而高通则不然，它叫“AIE”，就是“人工智能引擎”的意思，它通过CPU+GPU+DSP来实现AI运算，也能达到比较强的AI算力。&lt;/p&gt;
&lt;h3 id="isp"&gt;ISP
&lt;/h3&gt;&lt;p&gt;很多人可能觉得，手机拍照的强弱只取决于传感器CMOS的强弱，殊不知，搭载同一款CMOS的同一品牌不同型号手机拍出来的效果可能略有差异。在这其中，SOC里面的ISP起到了至关重要的作用。&lt;/p&gt;
&lt;p&gt;ISP，全称Image Signal Processor，中文叫“图像处理器”，不是GPU的“图形处理器”哦！它负责接收感光原件CMOS的原始数据，对这些数据进行“粗加工”，得到最后我们看到的照片。ISP需要与CMOS匹配，为什么去年不少手机都没有用4800W像素的CMOS呢？很简单，去年高通旗舰SOC骁龙845不支持4800W像素，如图：&lt;/p&gt;
&lt;p&gt;骁龙845最高支持1600W像素&lt;/p&gt;
&lt;p&gt;所以去年的手机厂商都使用了IMX363或者IMX380这两款1200W像素的CMOS。&lt;/p&gt;
&lt;h3 id="dsp"&gt;DSP
&lt;/h3&gt;&lt;p&gt;DSP虽然看起来不起眼，但实际对手机体验影响很大。它全称叫Digital Signal Processor，中文名叫“数字信号处理器”，不仅在手机中应用，在雷达、通信、图像处理、医疗电子、工业机器人等高密集计算领域都有广泛应用。在手机上，它主要负责语音处理，包括通话和语音输入，也负责一些图像处理的任务。&lt;/p&gt;
&lt;h3 id="基带modem"&gt;基带(modem)
&lt;/h3&gt;&lt;p&gt;手机最根本的功能还是通信，而掌管通信的芯片叫基带芯片，也有人称之为“调制解调器modem”，但实际上，手机的基带芯片不止包含modem。这个调制解调器的主要作用就是负责信号传输——所谓调制，就是把需要传输的信号通过一定的规则调制到载波上，让后通过无线收发器发送出去；解调则是相反的过程，类似把基站的语言“翻译成”手机能懂的，从而保证双方的顺畅交流，使我们能够接打电话、连接网络。&lt;/p&gt;
&lt;p&gt;目前SOC上的基带有两种不同的形式：一种叫集成基带，即厂商有能力将基带集成到SOC中，比如海思和高通都有这个能力；另一种则需要外挂，例如苹果。这也解释了为何XS系列信号不佳，因为使用了Intel的外挂基带，这个基带表现不给力。手机要支持某种网络，需要对应的基带，比如当前火热的5G，高通X55和华为巴龙5000都是基带芯片，但现在的骁龙855和麒麟980都没有集成5G基带，因此你看到的5G手机都是外挂基带的。&lt;/p&gt;
&lt;h3 id="协处理器"&gt;协处理器
&lt;/h3&gt;&lt;p&gt;这个相对来说比较容易解释，就如同它的名字一样，它负责一些比较轻量级的数据处理任务，比如指南针、气压计等，不需要每次都唤醒CPU处理，从而节省电量。苹果很早就在A7处理器上引入了M7协处理器，其他厂商的SOC也渐渐跟进了。&lt;/p&gt;
&lt;h3 id="存储与内存控制"&gt;存储与内存控制
&lt;/h3&gt;&lt;h3 id="电源管理"&gt;电源管理
&lt;/h3&gt;&lt;h2 id="reference"&gt;Reference
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://zhuanlan.zhihu.com/p/419093227" target="_blank" rel="noopener"
&gt;掌中核心——手机SOC基础知识科普&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>