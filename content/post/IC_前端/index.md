---
title: IC前端设计练习
description: 前端所有知识
date: 2025-07-29
image: cover.png
categories:
    - IC
tags:

weight: 3
---

## Verilog练习网址

[verilog在线练习](https://edu.eeeknow.com/exam/lab?uname=1138b6c7f20ffa138c04c6b81515e990&clname=wx)

[中文HDLBits](https://digitalasic.design/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3/hdlbits-chinese/)

[HDLBits完整版刷题](https://blog.csdn.net/wszwszwszqwer/article/details/123764784)

[优秀的开源项目](https://www.zhihu.com/question/348990787)

## verilog语法
###  `default_nettype none     
// Disable implicit nets. Reduces some types of bugs.
这是一个编译器指令（以反引号 ` 开头），不是 Verilog 语言的一部分。

设置当前源文件中，未显式声明的信号，不允许被自动推断为 wire。

隐式 nets 通常是难以检测的错误源。在 Verilog 中，通过赋值语句或将未声明的内容连接到模块端口，可以隐式创建网络类型信号。隐式 nets 始终是单一位宽的导线，并且如果你打算使用向量，它会导致错误。可以使用 default_nettype none 指令禁用隐式 nets 的创建。

```verilog
wire [2:0] a, c;     // 两个向量
assign a = 3'b101;   // a = 101
assign b = a;        // b = 1   隐式创建的导线
assign c = b;        // c = 001  <-- 错误
my_module i1 (d,e);  // 如果没有声明，d 和 e 隐式地是单一位宽。
```
// 如果端口本应是向量，这可能是一个错误。

添加 default_nettype none 将使代码的第二行成为一个错误，这使得错误更容易被发现。

### 组合逻辑
用于硬件综合的always块有两种：


 • 组合逻辑：always @(*)

 • 时钟触发：always @(posedge clk)

对于组合逻辑的always块，应始终使用(`*`) 敏感列表，显式列出信号容易出错，且在硬件综合时会被忽略。如果错过某个信号，综合后的硬件行为仍会像指定了(*)一样，但仿真时会不同步。在assign语句中，左侧必须是网络类型（如wire），而在always块的过程赋值中，左侧必须是变量类型（如reg）。这些类型与硬件综合无关，仅是Verilog作为硬件仿真语言的语法遗留。

> 一个“人口计数”电路用于计算输入向量中'1'的数量。构建一个用于3位输入向量的人口计数电路。
```verilog
module top_module( 
    input [2:0] in,
    output reg [1:0] out );

    // assign out = in[0] + in[1] + in[2];
    // 一直在报!!!!!


    always@(*) out = in[0] + in[1] + in[2];

    
endmodule
```



![alt text](image-1.png)

![alt text](image-2.png)
如果类型不对，会出现语法错误。


### 条件运算符（三元运算符）
用来实现 组合逻辑中基于选择信号的多路选择器（MUX）功能

> condition ? true_value : false_value;


https://edu.eeeknow.com/video-series?goods_sn=TW100943&series_goods_sn=XL101041&is_single=1&id=6019

### 阻塞赋值和非阻塞赋值
注意时序电路设计中的赋值语句要使用非阻塞赋值“<=”

[阻塞赋值和非阻塞赋值](https://blog.csdn.net/qq_44933149/article/details/121926211)

### 异步复位
在任意时刻（不依赖时钟边沿），只要复位信号有效（通常是低电平或高电平），寄存器立即被清零（或设置为初始值）。

| 对比项  | 异步复位                      | 同步复位                       |
| ---- | ------------------------- | -------------------------- |
| 触发时机 | **立即生效**，与时钟无关            | **在时钟上升沿/下降沿生效**           |
| 写法位置 | `if (!rst)` 在 `always` 开头 | `if (!rst)` 放在 `clk` 相关逻辑内 |
| 响应速度 | 快速响应，适合紧急清零               | 与时钟同步，响应稍慢                 |
| 通常用途 | 系统启动、电源不稳恢复               | 有严格时序控制的系统                 |

### 地址数x字长
我们常说的8x1 存储器

“8” 表示地址数（也就是存储单元个数），
“1” 表示每个存储单元可以存储1位（bit）的数据。

## 逻辑
### 移位寄存器
question：
我们现在有一个模块my_dff8，该模块具有两个输入和一个输出（实现一个8位的D触发器）。实例化它们中的三个，然后将它们链接在一起以构成一个长度为3的8位宽移位寄存器。
此外，创建一个4比1多路复用器，该多路复用器根据sel [1：0]选择输出的内容：输入d的值，在第一个，第二个之后或在第三个D触发器之后。 （**本质上，sel选择从0到3个时钟周期延迟输入的周期。**）
提供模块是：
module my_dff8 ( input clk, input [7:0] d, output [7:0] q );
没有提供多路复用器。一种可能的写方法是在always块中包含case语句。

![移位寄存器](./image.png)

### 真值表
SOP方法：输入使用“乘积”的形式，将每个为真的输出当作与门的输入

卡诺图：得出电路表达式
### 有符号溢出
这里从溢出发生的情形出发解题，有符号数溢出有两种情况：一是正正相加，产生正溢出;另一种情况是负负相减，产生负溢出。所以就分别考虑了这两种情况，将这两种情况取或判断溢出。

a[7] && b[7] && ~s[7]：

负数相减（补码相加）产生正数，判断溢出。

~a[7] && ~b[7] && s[7]：

正数相加产生一个负数，判断溢出。

| 情况        | a\[7] | b\[7] | s\[7] | 是否溢出  |
| --------- | ----- | ----- | ----- | ----- |
| 正 + 正 = 负 | 0     | 0     | 1     | ✅ 溢出  |
| 负 + 负 = 正 | 1     | 1     | 0     | ✅ 溢出  |
| 其余情况      | 0/1   | 1/0   | 无论什么  | ❌ 不溢出 |

```text
举个例子：
a =  1000_0000 = -128
b =  1000_0000 = -128
s = a + b = -128 + (-128) = -256

但 8 位补码最大表示范围是 [-128, 127]
-256 超出范围，结果会变成：

s = 0000_0000 （实际为 0） → s[7] = 0 ⇒ 溢出
```
---------------------------------------------

```text
a =  0111_1111 = 127
b =  0000_0001 =   1
s = a + b = 127 + 1 = 128

但 8 位补码最大表示范围是 [-128, 127]
128 超出范围，结果会变成：

s = 1000_0000 （实际为 -128） → s[7] = 1 ⇒ 溢出
```


### 边沿检查（时序逻辑检查）
位级并行上升沿检测（rising edge detection）问题，目标是检测一个 8 位信号向量中每一位何时发生 从 0 到 1 的变化，即上升沿，并在下一个时钟周期将相应输出位设为 1（其他位为 0）

**关键：确定上一个时钟周期的信号，使用 与门过滤**

[练习题](https://edu.eeeknow.com/video-series?goods_sn=TW100943&series_goods_sn=XL101041&is_single=1&id=6019)


🧠 基本原理：

对于一个信号 in[7:0]，我们需要对每一位 in[i] 做如下逻辑：

```verilog
out[i] = ~in_dly[i] & in[i];
```
其中：
in_dly[i] 是 in[i] 的上一个周期值（通过寄存器存下来的）。
out[i] 是当前周期输出的上升沿信号。

这条表达式的意思是：
如果 上一个周期是0 且 当前周期是1，说明发生了上升沿。

例子：

假设输入信号 in[7:0] 在 4 个时钟周期内的值如下
| Cycle | `in[7:0]`   |
| ----- | ----------- |
| 0     | 8'b00000000 |
| 1     | 8'b00010010 |
| 2     | 8'b00010011 |
| 3     | 8'b00010001 |


我们期望输出 out[7:0] 为：
| Cycle | `out[7:0]`  | **解释**              |
| ----- | ----------- | ------------------- |
| 0     | 8'b00000000 | 初始周期，没有比较基础         |
| 1     | 8'b00010010 | 第1位和第4位从 0→1，上升沿检测到 |
| 2     | 8'b00000001 | 第0位从 0→1 出现上升沿      |
| 3     | 8'b00000000 | 没有新的上升沿，out 全为0     |


