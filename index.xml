<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>UNO's Page</title><link>https://sleepman9.github.io/</link><description>Recent content on UNO's Page</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 09 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://sleepman9.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Git Practice</title><link>https://sleepman9.github.io/p/git-practice/</link><pubDate>Mon, 24 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/git-practice/</guid><description>&lt;img src="https://sleepman9.github.io/p/git-practice/cover.webp" alt="Featured image of post Git Practice" /&gt;&lt;h2 id="学习网站"&gt;学习网站
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener"
&gt;Learn Git Branching&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://git-scm.com/doc" target="_blank" rel="noopener"
&gt;Git文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="git代码基于实际开发流程"&gt;git代码（基于实际开发流程）
&lt;/h2&gt;&lt;p&gt;ps:在vscode中可以可视化仓库的变化情况&lt;/p&gt;
&lt;p&gt;ps:本文件主要使用命令行的形式，在vscode中可视化验证自己的操作是否正确&lt;/p&gt;
&lt;h2 id="1-clone代码"&gt;1. Clone代码
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;假设已经将代码&lt;code&gt;clone&lt;/code&gt;​到本地了&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="2-拉取远程仓库最新代码"&gt;2. 拉取远程仓库最新代码
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;​&lt;code&gt;git fetch&lt;/code&gt;​拉取远程所有更新。&lt;/p&gt;
&lt;p&gt;​&lt;img src="https://sleepman9.github.io/p/git-practice/assets/image-20241106100439-ut2gw03.png"
width="431"
height="401"
srcset="https://sleepman9.github.io/p/git-practice/assets/image-20241106100439-ut2gw03_hu_b2ceea911ac98b96.png 480w, https://sleepman9.github.io/p/git-practice/assets/image-20241106100439-ut2gw03_hu_eb844255352a0b8e.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="107"
data-flex-basis="257px"
&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以点击粉色节点查看变化内容。（这里不再使用git diff命令，可视化方便直观）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;code&gt;git merge&lt;/code&gt;​合并到当前分支&lt;/p&gt;
&lt;p&gt;​&lt;img src="https://sleepman9.github.io/p/git-practice/assets/image-20241106102009-gppsf65.png"
width="425"
height="388"
srcset="https://sleepman9.github.io/p/git-practice/assets/image-20241106102009-gppsf65_hu_58c9919f94ff609c.png 480w, https://sleepman9.github.io/p/git-practice/assets/image-20241106102009-gppsf65_hu_bd0840c3a991e83f.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="109"
data-flex-basis="262px"
&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="3提交代码"&gt;3.提交代码
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;​&lt;code&gt;git add .&lt;/code&gt;​将修改存入暂存区（stage）&lt;/li&gt;
&lt;li&gt;​&lt;code&gt;git commit -m &amp;quot;备注信息&amp;quot;&lt;/code&gt;​提交已经存入到stage的内容&lt;/li&gt;
&lt;li&gt;​&lt;code&gt;git push origin wwh_dev&lt;/code&gt;​将本地的&lt;code&gt;wwh_dev&lt;/code&gt;​分支，推送到&lt;code&gt;origin&lt;/code&gt;​远端&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;背景：在main分支开发完毕后，在没有commit的情况下，新建了分支mph_generator_dev当作是本次开发的备份，同样在没有commit的情况下，又新建了一个分支wwh_dev当作是提交分支。&lt;/p&gt;
&lt;p&gt;warning：当我执行完&lt;code&gt;git push origin wwh_dev&lt;/code&gt;​ 后，其他分支的内容都回到了修改前&lt;br&gt;
​&lt;img src="https://sleepman9.github.io/p/git-practice/assets/image-20241112102741-63lyvcr.png"
width="378"
height="197"
srcset="https://sleepman9.github.io/p/git-practice/assets/image-20241112102741-63lyvcr_hu_67b891a07e6d5a87.png 480w, https://sleepman9.github.io/p/git-practice/assets/image-20241112102741-63lyvcr_hu_827500bc74a74ce3.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="191"
data-flex-basis="460px"
&gt;​&lt;br&gt;
​&lt;img src="https://sleepman9.github.io/p/git-practice/assets/image-20241112102556-4b9js4p.png"
width="363"
height="198"
srcset="https://sleepman9.github.io/p/git-practice/assets/image-20241112102556-4b9js4p_hu_1d76fda89d3b8169.png 480w, https://sleepman9.github.io/p/git-practice/assets/image-20241112102556-4b9js4p_hu_3cc845b386b99610.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
&gt;​&lt;/p&gt;
&lt;p&gt;error:猜想造成的原因是，创建其他分支之前没有&lt;code&gt;commit&lt;/code&gt;​ 造成的。此想法还没有验证。（TODO）&lt;/p&gt;
&lt;p&gt;main分支没有commit的情况下新建了A分支，A分支git commit之后，main分支所有修改都消失了&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;h2 id="4向管理者提交pull-requests"&gt;4.向管理者提交pull requests
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在GUI页面中进行的。&lt;/p&gt;
&lt;p&gt;​&lt;img src="https://sleepman9.github.io/p/git-practice/assets/image-20241202141543-hlc6qfm.png"
width="642"
height="846"
srcset="https://sleepman9.github.io/p/git-practice/assets/image-20241202141543-hlc6qfm_hu_8da8d81258755ae6.png 480w, https://sleepman9.github.io/p/git-practice/assets/image-20241202141543-hlc6qfm_hu_56f223bb94384da9.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="75"
data-flex-basis="182px"
&gt;​&lt;/p&gt;
&lt;p&gt;​&lt;img src="https://sleepman9.github.io/p/git-practice/assets/image-20241202141630-8z1rx41.png"
width="2072"
height="390"
srcset="https://sleepman9.github.io/p/git-practice/assets/image-20241202141630-8z1rx41_hu_8b1f94b446f00a0f.png 480w, https://sleepman9.github.io/p/git-practice/assets/image-20241202141630-8z1rx41_hu_f6730684ae34fb9a.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="531"
data-flex-basis="1275px"
&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;源分支：开发完成的分支&lt;/p&gt;
&lt;p&gt;目标分支：项目分支&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;p&gt;解决冲突&lt;/p&gt;
&lt;p&gt;在GUI界面上解决，并且在GUI界面，&lt;code&gt;git add .&lt;/code&gt;​和&lt;code&gt;git commit -m &amp;quot;备注信息&amp;quot;&lt;/code&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;等待管理员接受PR,合并代码后，以此开发任务就完成了。&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;h3 id="41查看是否提交成功"&gt;4.1查看是否提交成功
&lt;/h3&gt;&lt;p&gt;背景：在wwh_dev分支上开发，提交代码后，merge之后，想在其他分支看我提交的内容，同时保证一个分支时刻保持最新。问题来了。在Thermal5.0（想要保持最新的分支）看不到我提交的内容。&lt;/p&gt;
&lt;p&gt;原因在于没有进行分支追踪：&lt;br&gt;
执行 &lt;code&gt;git pull &amp;lt;远程&amp;gt; &amp;lt;分支&amp;gt;&lt;/code&gt;​ 例如：git pull origin Thermal5.0&lt;br&gt;
执行之后，即可得到最新提交代码&lt;/p&gt;
&lt;h3 id="42-添加分支跟踪"&gt;4.2 添加分支跟踪
&lt;/h3&gt;&lt;p&gt;手动：&lt;/p&gt;
&lt;p&gt;​&lt;code&gt;git branch --set-upstream-to=&amp;lt;remote_name&amp;gt;/&amp;lt;remote_branch&amp;gt; &amp;lt;branch_name&amp;gt;&lt;/code&gt;​&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;新建分支的时候建立追踪关系：&lt;/p&gt;
&lt;p&gt;​&lt;code&gt;git checkout -b my_branch origin/develop&lt;/code&gt;​&lt;/p&gt;
&lt;p&gt;​&lt;code&gt;git switch -c my_branch origin/develop&lt;/code&gt;​&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;h3 id="43-查看跟踪分支"&gt;4.3 查看跟踪分支
&lt;/h3&gt;&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;git branch -vv&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;h2 id="5-再开启一个新开发任务"&gt;5. 再开启一个新开发任务
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分支分配&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;​&lt;code&gt;main&lt;/code&gt;​分支，保持和origin远端的同步，不要在这个上面开发&lt;/li&gt;
&lt;li&gt;​&lt;code&gt;dev&lt;/code&gt;​分支，每次最新任务的开发分支&lt;/li&gt;
&lt;li&gt;​&lt;code&gt;dev_xx_backup&lt;/code&gt;​分支，开发完一个任务后的备份，拷贝来自&lt;code&gt;dev&lt;/code&gt;​分支，包含任务测试代码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分支管理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次&lt;code&gt;push&lt;/code&gt;​提交后，等待管理员检查无误后，将&lt;code&gt;dev&lt;/code&gt;​分支删除&lt;/li&gt;
&lt;li&gt;保证&lt;code&gt;main&lt;/code&gt;​分支最新，从&lt;code&gt;main&lt;/code&gt;​分支中新建一个分支当成当前任务的分支&lt;/li&gt;
&lt;li&gt;此时&lt;code&gt;branch&lt;/code&gt;​结构中只包含，一个&lt;code&gt;main&lt;/code&gt;​分支，一个&lt;code&gt;dev&lt;/code&gt;​分支，和&lt;code&gt;每次任务的备份&lt;/code&gt;​分支&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;h2 id="6source-control-graph"&gt;6.SOURCE CONTROL GRAPH
&lt;/h2&gt;&lt;p&gt;ps：图片都来自&lt;code&gt;vscode&lt;/code&gt;​&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;来自于&lt;code&gt;git fetch&lt;/code&gt;​之后&lt;/p&gt;
&lt;p&gt;​&lt;img src="https://sleepman9.github.io/assets/%e5%b1%8f%e5%b9%95%e6%88%aa%e5%9b%be%202024-11-12%20143950-20241112152941-6iufqqs.png"
loading="lazy"
alt="屏幕截图 2024-11-12 143950"
&gt;​&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每一个实心圆代表每一次提交节点&lt;/li&gt;
&lt;li&gt;不同颜色的线，表示不同开发人员的开发路线&lt;/li&gt;
&lt;li&gt;&lt;span data-type="text" style="background-color: var(--b3-card-info-background); color: var(--b3-card-info-color);"&gt;蓝色空心圆&lt;/span&gt;表示当前所在的节点&lt;/li&gt;
&lt;li&gt;圆环表示合并操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;来自&lt;code&gt;git merge&lt;/code&gt;​之后&lt;/p&gt;
&lt;p&gt;​&lt;img src="https://sleepman9.github.io/p/git-practice/assets/image-20241112153120-r572v33.png"
width="458"
height="286"
srcset="https://sleepman9.github.io/p/git-practice/assets/image-20241112153120-r572v33_hu_a74d3a04e2b71395.png 480w, https://sleepman9.github.io/p/git-practice/assets/image-20241112153120-r572v33_hu_2690fe9e1b9906c4.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="160"
data-flex-basis="384px"
&gt;​&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;框中标注的部分，当时是在GUI界面上修改分支冲突的，所以会从蓝色线程中分出一个分支到橙色线程的合并&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="删除远程分支"&gt;删除远程分支
&lt;/h2&gt;&lt;p&gt;‍要删除 Git 仓库中的&lt;strong&gt;远程分支&lt;/strong&gt;，你可以使用以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git push &amp;lt;remote_name&amp;gt; --delete &amp;lt;branch_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git push origin --delete feature/login
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这条命令会将远程名为 &lt;code&gt;origin&lt;/code&gt; 的仓库中的 &lt;code&gt;feature/login&lt;/code&gt; 分支删除。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;常见说明&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;remote_name&amp;gt;&lt;/code&gt; 通常是 &lt;code&gt;origin&lt;/code&gt;，可以通过 &lt;code&gt;git remote -v&lt;/code&gt; 查看。&lt;/li&gt;
&lt;li&gt;删除远程分支不会影响本地的分支，如果你也想删除本地的，可以用：
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git branch -d &amp;lt;branch_name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;</description></item><item><title>Hugo Github Pages 搭建个人博客</title><link>https://sleepman9.github.io/p/hugo-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link><pubDate>Fri, 28 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/hugo-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid><description>&lt;img src="https://sleepman9.github.io/p/hugo-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/cover.png" alt="Featured image of post Hugo Github Pages 搭建个人博客" /&gt;&lt;h2 id="手动搭建博客经历"&gt;手动搭建博客经历
&lt;/h2&gt;&lt;h3 id="手动方式"&gt;手动方式：
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装：&lt;code&gt;hugo&lt;/code&gt;, &lt;code&gt;go&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;clone 主题：&lt;code&gt;git submodule add theme&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;hugo server 本地调试。&lt;/li&gt;
&lt;li&gt;设置GitHub Pages主页信息&lt;/li&gt;
&lt;li&gt;使用GitHub Actions 自动构建/部署（CI/CD）&lt;/li&gt;
&lt;li&gt;本地提交到GitHub仓库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述过程可以参考
&lt;a class="link" href="https://blog.taoluyuan.com/blog/github-workflows" target="_blank" rel="noopener"
&gt;通过 Github workflows CI/CD 自动化部署 Github Pages hugo 免费博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://jianzhnie.github.io/post/hugo_site/" target="_blank" rel="noopener"
&gt;Hugo + Github Pages 搭建个人博客&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="template方式"&gt;template方式
&lt;/h3&gt;&lt;p&gt;直到后来遇到了&lt;strong&gt;自动挡&lt;/strong&gt;，直接使用 theme template套模板即可（修改个人信息，写post）&lt;/p&gt;
&lt;h3 id="个人感悟"&gt;个人感悟
&lt;/h3&gt;&lt;p&gt;最近在接触软件开发的内容，其中对于CI/CD部分一直存在一些疑惑，直到自己搭建博客，对这一块的工作流有了进一步的理解。&lt;/p&gt;
&lt;h2 id="hugo-stack-theme-魔改"&gt;hugo stack theme 魔改
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;多看优秀的主题，才知道怎么魔改；链接及其评论作者都是与此相关的主题；&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="link" href="https://linsnow.cn/posts/bloglab/hugo-stack/modify-hugo/" target="_blank" rel="noopener"
&gt;bloger1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.xalaok.top/post/stack-modify/" target="_blank" rel="noopener"
&gt;stack 魔改美化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://thirdshire.com/hugo-stack-renovation/" target="_blank" rel="noopener"
&gt;stack 魔改美化_2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.reincarnatey.net/2023/build-hugo-blog-with-stack-mod/" target="_blank" rel="noopener"
&gt;建站技术 | 使用 Hugo + Stack 简单搭建一个博客&lt;/a&gt;&lt;/p&gt;</description></item><item><title>IC前端设计练习</title><link>https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/</link><pubDate>Tue, 29 Jul 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/</guid><description>&lt;img src="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/cover.png" alt="Featured image of post IC前端设计练习" /&gt;&lt;h2 id="verilog练习网址"&gt;Verilog练习网址
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://edu.eeeknow.com/exam/lab?uname=1138b6c7f20ffa138c04c6b81515e990&amp;amp;clname=wx" target="_blank" rel="noopener"
&gt;verilog在线练习&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://digitalasic.design/%e7%bf%bb%e8%af%91%e6%96%87%e6%a1%a3/hdlbits-chinese/" target="_blank" rel="noopener"
&gt;中文HDLBits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/wszwszwszqwer/article/details/123764784" target="_blank" rel="noopener"
&gt;HDLBits完整版刷题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.zhihu.com/question/348990787" target="_blank" rel="noopener"
&gt;优秀的开源项目&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="verilog语法"&gt;verilog语法
&lt;/h2&gt;&lt;h3 id="default_nettype-none"&gt;`default_nettype none
&lt;/h3&gt;&lt;p&gt;// Disable implicit nets. Reduces some types of bugs.
这是一个编译器指令（以反引号 ` 开头），不是 Verilog 语言的一部分。&lt;/p&gt;
&lt;p&gt;设置当前源文件中，未显式声明的信号，不允许被自动推断为 wire。&lt;/p&gt;
&lt;p&gt;隐式 nets 通常是难以检测的错误源。在 Verilog 中，通过赋值语句或将未声明的内容连接到模块端口，可以隐式创建网络类型信号。隐式 nets 始终是单一位宽的导线，并且如果你打算使用向量，它会导致错误。可以使用 default_nettype none 指令禁用隐式 nets 的创建。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-verilog" data-lang="verilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 两个向量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b101&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// a = 101
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// b = 1 隐式创建的导线
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// c = 001 &amp;lt;-- 错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;my_module&lt;/span&gt; &lt;span class="n"&gt;i1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 如果没有声明，d 和 e 隐式地是单一位宽。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;// 如果端口本应是向量，这可能是一个错误。&lt;/p&gt;
&lt;p&gt;添加 default_nettype none 将使代码的第二行成为一个错误，这使得错误更容易被发现。&lt;/p&gt;
&lt;h3 id="组合逻辑"&gt;组合逻辑
&lt;/h3&gt;&lt;p&gt;用于硬件综合的always块有两种：&lt;/p&gt;
&lt;p&gt;• 组合逻辑：always @(*)&lt;/p&gt;
&lt;p&gt;• 时钟触发：always @(posedge clk)&lt;/p&gt;
&lt;p&gt;对于组合逻辑的always块，应始终使用(&lt;code&gt;*&lt;/code&gt;) 敏感列表，显式列出信号容易出错，且在硬件综合时会被忽略。如果错过某个信号，综合后的硬件行为仍会像指定了(*)一样，但仿真时会不同步。在assign语句中，左侧必须是网络类型（如wire），而在always块的过程赋值中，左侧必须是变量类型（如reg）。这些类型与硬件综合无关，仅是Verilog作为硬件仿真语言的语法遗留。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个“人口计数”电路用于计算输入向量中'1&amp;rsquo;的数量。构建一个用于3位输入向量的人口计数电路。&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-verilog" data-lang="verilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;top_module&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// assign out = in[0] + in[1] + in[2];
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// 一直在报!!!!!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-1.png"
width="1134"
height="675"
srcset="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-1_hu_3951abdcfab3e8d0.png 480w, https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-1_hu_e339074d26b7e883.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="403px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-2.png"
width="900"
height="630"
srcset="https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-2_hu_e99c9dfd220514d1.png 480w, https://sleepman9.github.io/p/ic%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/image-2_hu_1e89b388b2fd7e84.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="342px"
&gt;
如果类型不对，会出现语法错误。&lt;/p&gt;
&lt;h3 id="条件运算符三元运算符"&gt;条件运算符（三元运算符）
&lt;/h3&gt;&lt;p&gt;用来实现 组合逻辑中基于选择信号的多路选择器（MUX）功能&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;condition ? true_value : false_value;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="link" href="https://edu.eeeknow.com/video-series?goods_sn=TW100943&amp;amp;series_goods_sn=XL101041&amp;amp;is_single=1&amp;amp;id=6019" target="_blank" rel="noopener"
&gt;https://edu.eeeknow.com/video-series?goods_sn=TW100943&amp;series_goods_sn=XL101041&amp;is_single=1&amp;id=6019&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="阻塞赋值和非阻塞赋值"&gt;阻塞赋值和非阻塞赋值
&lt;/h3&gt;&lt;p&gt;注意时序电路设计中的赋值语句要使用非阻塞赋值“&amp;lt;=”&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_44933149/article/details/121926211" target="_blank" rel="noopener"
&gt;阻塞赋值和非阻塞赋值&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="异步复位"&gt;异步复位
&lt;/h3&gt;&lt;p&gt;在任意时刻（不依赖时钟边沿），只要复位信号有效（通常是低电平或高电平），寄存器立即被清零（或设置为初始值）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对比项&lt;/th&gt;
&lt;th&gt;异步复位&lt;/th&gt;
&lt;th&gt;同步复位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;触发时机&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;立即生效&lt;/strong&gt;，与时钟无关&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;在时钟上升沿/下降沿生效&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;写法位置&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if (!rst)&lt;/code&gt; 在 &lt;code&gt;always&lt;/code&gt; 开头&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if (!rst)&lt;/code&gt; 放在 &lt;code&gt;clk&lt;/code&gt; 相关逻辑内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;响应速度&lt;/td&gt;
&lt;td&gt;快速响应，适合紧急清零&lt;/td&gt;
&lt;td&gt;与时钟同步，响应稍慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;通常用途&lt;/td&gt;
&lt;td&gt;系统启动、电源不稳恢复&lt;/td&gt;
&lt;td&gt;有严格时序控制的系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="地址数x字长"&gt;地址数x字长
&lt;/h3&gt;&lt;p&gt;我们常说的8x1 存储器&lt;/p&gt;
&lt;p&gt;“8” 表示地址数（也就是存储单元个数），
“1” 表示每个存储单元可以存储1位（bit）的数据。&lt;/p&gt;
&lt;h2 id="逻辑"&gt;逻辑
&lt;/h2&gt;&lt;h3 id="移位寄存器"&gt;移位寄存器
&lt;/h3&gt;&lt;p&gt;question：
我们现在有一个模块my_dff8，该模块具有两个输入和一个输出（实现一个8位的D触发器）。实例化它们中的三个，然后将它们链接在一起以构成一个长度为3的8位宽移位寄存器。
此外，创建一个4比1多路复用器，该多路复用器根据sel [1：0]选择输出的内容：输入d的值，在第一个，第二个之后或在第三个D触发器之后。 （&lt;strong&gt;本质上，sel选择从0到3个时钟周期延迟输入的周期。&lt;/strong&gt;）
提供模块是：
module my_dff8 ( input clk, input [7:0] d, output [7:0] q );
没有提供多路复用器。一种可能的写方法是在always块中包含case语句。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/image.png"
loading="lazy"
alt="移位寄存器"
&gt;&lt;/p&gt;
&lt;h3 id="真值表"&gt;真值表
&lt;/h3&gt;&lt;p&gt;SOP方法：输入使用“乘积”的形式，将每个为真的输出当作与门的输入&lt;/p&gt;
&lt;p&gt;卡诺图：得出电路表达式&lt;/p&gt;
&lt;h3 id="有符号溢出"&gt;有符号溢出
&lt;/h3&gt;&lt;p&gt;这里从溢出发生的情形出发解题，有符号数溢出有两种情况：一是正正相加，产生正溢出;另一种情况是负负相减，产生负溢出。所以就分别考虑了这两种情况，将这两种情况取或判断溢出。&lt;/p&gt;
&lt;p&gt;a[7] &amp;amp;&amp;amp; b[7] &amp;amp;&amp;amp; ~s[7]：&lt;/p&gt;
&lt;p&gt;负数相减（补码相加）产生正数，判断溢出。&lt;/p&gt;
&lt;p&gt;~a[7] &amp;amp;&amp;amp; ~b[7] &amp;amp;&amp;amp; s[7]：&lt;/p&gt;
&lt;p&gt;正数相加产生一个负数，判断溢出。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;情况&lt;/th&gt;
&lt;th&gt;a[7]&lt;/th&gt;
&lt;th&gt;b[7]&lt;/th&gt;
&lt;th&gt;s[7]&lt;/th&gt;
&lt;th&gt;是否溢出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;正 + 正 = 负&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;✅ 溢出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;负 + 负 = 正&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;✅ 溢出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其余情况&lt;/td&gt;
&lt;td&gt;0/1&lt;/td&gt;
&lt;td&gt;1/0&lt;/td&gt;
&lt;td&gt;无论什么&lt;/td&gt;
&lt;td&gt;❌ 不溢出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;举个例子：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;a = 1000_0000 = -128
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;b = 1000_0000 = -128
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;s = a + b = -128 + (-128) = -256
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;但 8 位补码最大表示范围是 [-128, 127]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;-256 超出范围，结果会变成：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;s = 0000_0000 （实际为 0） → s[7] = 0 ⇒ 溢出
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;a = 0111_1111 = 127
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;b = 0000_0001 = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;s = a + b = 127 + 1 = 128
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;但 8 位补码最大表示范围是 [-128, 127]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;128 超出范围，结果会变成：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;s = 1000_0000 （实际为 -128） → s[7] = 1 ⇒ 溢出
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="边沿检查时序逻辑检查"&gt;边沿检查（时序逻辑检查）
&lt;/h3&gt;&lt;p&gt;位级并行上升沿检测（rising edge detection）问题，目标是检测一个 8 位信号向量中每一位何时发生 从 0 到 1 的变化，即上升沿，并在下一个时钟周期将相应输出位设为 1（其他位为 0）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键：确定上一个时钟周期的信号，使用 与门过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://edu.eeeknow.com/video-series?goods_sn=TW100943&amp;amp;series_goods_sn=XL101041&amp;amp;is_single=1&amp;amp;id=6019" target="_blank" rel="noopener"
&gt;练习题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;🧠 基本原理：&lt;/p&gt;
&lt;p&gt;对于一个信号 in[7:0]，我们需要对每一位 in[i] 做如下逻辑：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-verilog" data-lang="verilog"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;in_dly&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中：
in_dly[i] 是 in[i] 的上一个周期值（通过寄存器存下来的）。
out[i] 是当前周期输出的上升沿信号。&lt;/p&gt;
&lt;p&gt;这条表达式的意思是：
如果 上一个周期是0 且 当前周期是1，说明发生了上升沿。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;假设输入信号 in[7:0] 在 4 个时钟周期内的值如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Cycle&lt;/th&gt;
&lt;th&gt;&lt;code&gt;in[7:0]&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00010010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00010011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00010001&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们期望输出 out[7:0] 为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Cycle&lt;/th&gt;
&lt;th&gt;&lt;code&gt;out[7:0]&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00000000&lt;/td&gt;
&lt;td&gt;初始周期，没有比较基础&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00010010&lt;/td&gt;
&lt;td&gt;第1位和第4位从 0→1，上升沿检测到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00000001&lt;/td&gt;
&lt;td&gt;第0位从 0→1 出现上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;8&amp;rsquo;b00000000&lt;/td&gt;
&lt;td&gt;没有新的上升沿，out 全为0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description></item><item><title>软件开发——编译</title><link>https://sleepman9.github.io/p/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%BC%96%E8%AF%91/</link><pubDate>Fri, 18 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%BC%96%E8%AF%91/</guid><description>&lt;blockquote&gt;
&lt;p&gt;伟大的UNO一般会问几个为什么！&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="qa"&gt;QA
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Q：为什么要编译成动态库&lt;/p&gt;
&lt;p&gt;A:为了&lt;strong&gt;节省资源、方便更新、支持模块化和跨语言调用&lt;/strong&gt;，还能实现插件式架构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q: CMake的构建和编译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q：怎么通过error信息定位解决&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="动态库"&gt;动态库
&lt;/h2&gt;&lt;h3 id="基本概念"&gt;基本概念
&lt;/h3&gt;&lt;p&gt;动态库就是 &lt;code&gt;.so&lt;/code&gt;（Linux）、&lt;code&gt;.dll&lt;/code&gt;（Windows）、&lt;code&gt;.dylib&lt;/code&gt;（macOS） 这样的文件，在程序运行时被“动态加载”。&lt;/p&gt;
&lt;p&gt;它跟 &lt;strong&gt;静态库&lt;/strong&gt;（&lt;code&gt;.a&lt;/code&gt; 或 &lt;code&gt;.lib&lt;/code&gt;）的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态库是&lt;strong&gt;编译时就嵌入程序里&lt;/strong&gt;的，生成的可执行文件比较大。&lt;/li&gt;
&lt;li&gt;动态库是&lt;strong&gt;运行时才加载&lt;/strong&gt;的，可执行文件会“引用”这个库，而不是包含它本体。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;✅ 为什么编译成动态库？有哪些优点？
&lt;strong&gt;节省内存和磁盘空间&lt;/strong&gt;
多个程序都能使用同一个动态库，比如系统的 libc.so、OpenCV、Qt 这些常用库，不用每个程序都各自编译一份，节省资源。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;支持模块化设计&lt;/strong&gt;
程序可以把功能拆成多个模块，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个主程序（main app）&lt;/li&gt;
&lt;li&gt;一些插件/功能模块（编译成动态库）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样设计更灵活、更易维护。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;支持“热更新”或“热插拔”&lt;/strong&gt;
当你想更新某个模块的功能，只需要替换掉对应的动态库，而不用重新编译整个程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插件机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 的 &lt;code&gt;.pyd&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;MATLAB 的 MEX 动态库&lt;/li&gt;
&lt;li&gt;浏览器的扩展插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些都是通过动态库的形式扩展主程序的功能。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;跨语言调用&lt;/strong&gt;
很多时候，我们用 C/C++ 写一个高性能的核心模块，然后 Python、Java 等其他语言用 FFI（Foreign Function Interface） 调用这些库。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Python 通过 ctypes 加载 .so 或 .dll&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;ctypes&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cdll&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;lib&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cdll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LoadLibrary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;./libexample.so&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h3 id="怎么生成动态库链接使用动态库"&gt;怎么生成动态库，链接使用动态库
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;源代码&lt;/li&gt;
&lt;li&gt;编译生成动态库&lt;/li&gt;
&lt;li&gt;写主程序&lt;/li&gt;
&lt;li&gt;编译主程序时链接动态库&lt;/li&gt;
&lt;li&gt;运行主程序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;太好了，我们就用最常见的 &lt;strong&gt;C/C++&lt;/strong&gt; 来举个例子，展示一下 &lt;strong&gt;怎么编译生成动态库&lt;/strong&gt;（以 Linux 下为例，也会顺便说下 Windows 和 macOS 的差异）。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id="创建源代码文件"&gt;创建源代码文件
&lt;/h4&gt;&lt;p&gt;👉 动态库源文件：&lt;code&gt;mymath.c&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// mymath.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;say_hello&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;Hello from dynamic library!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;👉 头文件：&lt;code&gt;mymath.h&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// mymath.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="cp"&gt;#ifndef MYMATH_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#define MYMATH_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;say_hello&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h4 id="-2-编译生成动态库"&gt;🛠️ 2. 编译生成动态库
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Linux / macOS：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;gcc -fPIC -shared -o libmymath.so mymath.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-fPIC&lt;/code&gt;：生成位置无关代码（Position Independent Code），动态库需要这个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-shared&lt;/code&gt;：告诉编译器要生成共享库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o libmymath.so&lt;/code&gt;：输出文件名，&lt;code&gt;lib&lt;/code&gt; 开头是习惯命名方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Windows（使用 MinGW）：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;gcc -shared -o mymath.dll mymath.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h4 id="-3-写主程序调用它mainc"&gt;🧪 3. 写主程序调用它：&lt;code&gt;main.c&lt;/code&gt;
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// main.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;#34;mymath.h&amp;#34;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;say_hello&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;3 + 5 = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h4 id="-4-编译主程序时链接动态库"&gt;🏗️ 4. 编译主程序时链接动态库
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;gcc -o main main.c -L. -lmymath
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-L.&lt;/code&gt; 表示在当前目录找库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-lmymath&lt;/code&gt; 表示链接名为 &lt;code&gt;libmymath.so&lt;/code&gt; 的库（&lt;code&gt;lib&lt;/code&gt; 开头省略，&lt;code&gt;.so&lt;/code&gt; 后缀省略）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="-5-运行程序linux"&gt;🏃 5. 运行程序（Linux）
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;LD_LIBRARY_PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;. ./main
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;LD_LIBRARY_PATH=.&lt;/code&gt; 是告诉系统动态库就放在当前目录&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;🎉 &lt;strong&gt;输出结果&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Hello from dynamic library!
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;3 + 5 = 8
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;✅ &lt;strong&gt;小结一波&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;步骤&lt;/th&gt;
&lt;th&gt;命令或操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;写库代码&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mymath.c&lt;/code&gt;、&lt;code&gt;mymath.h&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编译库&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gcc -fPIC -shared -o libmymath.so mymath.c&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;写主程序&lt;/td&gt;
&lt;td&gt;&lt;code&gt;main.c&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编译主程序&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gcc -o main main.c -L. -lmymath&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;运行程序&lt;/td&gt;
&lt;td&gt;&lt;code&gt;LD_LIBRARY_PATH=. ./main&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="cmake"&gt;CMake
&lt;/h2&gt;&lt;p&gt;CMake 是一个 跨平台的自动化构建系统工具，它使用一种称为 CMakeLists.txt 的配置文件来描述如何生成项目的构建文件（例如 Makefile 或 Visual Studio 工程）。&lt;/p&gt;
&lt;p&gt;构建文件中有编译命令GCC,G++等；编译程序；&lt;/p&gt;
&lt;h3 id="基本概念-1"&gt;基本概念
&lt;/h3&gt;&lt;h4 id="-cmake-的基本构建流程"&gt;📁 CMake 的基本构建流程
&lt;/h4&gt;&lt;p&gt;CMake 的构建过程分为两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;配置（Configure）阶段&lt;/strong&gt;
这一阶段的目标是生成平台相关的构建文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;cmake -S . -B build
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-S .&lt;/code&gt; 指定源码路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-B build&lt;/code&gt; 指定生成的构建文件放在哪个目录（可以叫 &lt;code&gt;build&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时，CMake 会读取 &lt;code&gt;CMakeLists.txt&lt;/code&gt;，根据系统环境、编译器等生成合适的构建系统（比如 Makefile）。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;构建（Build）阶段&lt;/strong&gt;
使用上一步生成的构建文件，开始真正的&lt;strong&gt;编译&lt;/strong&gt;操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;cmake --build build
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这一步等价于执行 &lt;code&gt;make&lt;/code&gt;（如果你使用的是 Unix/Linux 上的默认生成器），将源代码编译成可执行文件或者库。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id="-cmakeliststxt-基础结构"&gt;📜 CMakeLists.txt 基础结构
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cmake" data-lang="cmake"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;cmake_minimum_required&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;VERSION&lt;/span&gt; &lt;span class="s"&gt;3.10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="nb"&gt;project&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;MyProject&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 指定 C++ 标准
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;CMAKE_CXX_STANDARD&lt;/span&gt; &lt;span class="s"&gt;17&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 添加源文件并构建成可执行文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;add_executable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;my_app&lt;/span&gt; &lt;span class="s"&gt;main.cpp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;project(...)&lt;/code&gt;：定义项目名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set(...)&lt;/code&gt;：设置变量，比如 C++ 标准&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add_executable(...)&lt;/code&gt;：指定编译可执行文件的目标&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;🔁 &lt;strong&gt;常见命令一览&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;命令示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;配置&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cmake -S . -B build&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;构建&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cmake --build build&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;清除构建目录&lt;/td&gt;
&lt;td&gt;&lt;code&gt;rm -rf build&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设置编译器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CC=gcc CXX=g++ cmake -S . -B build&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;💡 &lt;strong&gt;小技巧&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始终将构建目录和源代码目录分离（Out-of-Source Build），便于管理。&lt;/li&gt;
&lt;li&gt;可以加上 &lt;code&gt;-DCMAKE_BUILD_TYPE=Release&lt;/code&gt; 或 &lt;code&gt;Debug&lt;/code&gt; 来控制编译类型。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;target_include_directories&lt;/code&gt; 和 &lt;code&gt;target_link_libraries&lt;/code&gt; 来管理依赖更清晰。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="应用"&gt;应用
&lt;/h3&gt;&lt;p&gt;使用 CMake 来构建上述小项目：生成动态库 &lt;code&gt;libmymath.so&lt;/code&gt;，并编译主程序 &lt;code&gt;main.c&lt;/code&gt; 来调用它。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id="项目结构"&gt;项目结构
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;my_project/
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;├── CMakeLists.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;├── mymath.c
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;├── mymath.h
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;└── main.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h4 id="cmakeliststxt-内容"&gt;CMakeLists.txt 内容
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cmake" data-lang="cmake"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;cmake_minimum_required&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;VERSION&lt;/span&gt; &lt;span class="s"&gt;3.10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="nb"&gt;project&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;MyDynamicLibExample&lt;/span&gt; &lt;span class="s"&gt;C&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 设置编译为 C99
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;CMAKE_C_STANDARD&lt;/span&gt; &lt;span class="s"&gt;99&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 设置输出目录
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;CMAKE_LIBRARY_OUTPUT_DIRECTORY&lt;/span&gt; &lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;CMAKE_BINARY_DIR&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="s"&gt;/lib&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;CMAKE_RUNTIME_OUTPUT_DIRECTORY&lt;/span&gt; &lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;CMAKE_BINARY_DIR&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="s"&gt;/bin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 创建动态库
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;add_library&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;mymath&lt;/span&gt; &lt;span class="s"&gt;SHARED&lt;/span&gt; &lt;span class="s"&gt;mymath.c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 创建可执行文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;add_executable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;main_exec&lt;/span&gt; &lt;span class="s"&gt;main.c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 链接动态库到可执行程序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;target_link_libraries&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;main_exec&lt;/span&gt; &lt;span class="s"&gt;PRIVATE&lt;/span&gt; &lt;span class="s"&gt;mymath&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 设置头文件路径（可选）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;target_include_directories&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;main_exec&lt;/span&gt; &lt;span class="s"&gt;PRIVATE&lt;/span&gt; &lt;span class="o"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h4 id="构建步骤在-linuxmacos-上"&gt;构建步骤（在 Linux/macOS 上）
&lt;/h4&gt;&lt;p&gt;打开终端：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;mkdir build
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; build
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;cmake ..
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;cmake --build .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h4 id="行程序"&gt;行程序
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;LD_LIBRARY_PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;./lib ./bin/main_exec
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Hello from dynamic library!
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;3 + 5 = 8
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="动态库调用外部函数"&gt;动态库调用外部函数
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://www.cnblogs.com/sewain/p/14798200.html" target="_blank" rel="noopener"
&gt;应用程序设计：在动态库中如何调用外部函数？&lt;/a&gt;&lt;/p&gt;</description></item><item><title>AI_Model_Transformer</title><link>https://sleepman9.github.io/p/ai_model_transformer/</link><pubDate>Wed, 26 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/ai_model_transformer/</guid><description>&lt;img src="https://sleepman9.github.io/p/ai_model_transformer/cover.png" alt="Featured image of post AI_Model_Transformer" /&gt;&lt;p&gt;&lt;strong&gt;如果你开始提问，那说明你开始进步了！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;前言：一直有个困惑？看完了整个过程，具体是怎么是怎么实现翻译功能的？
后知后觉的理解：一连串的变换矩阵变换，最终只是为了找到不同词库中的位置！也就是概率分布！！
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="词的embedding怎么表示的"&gt;词的Embedding怎么表示的？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;简洁回答：使用训练模型得出一串向量！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词的 Embedding 有很多种方式可以获取，例如可以采用 Word2Vec、Glove 等算法预训练得到，也可以在 Transformer 中训练得到。举个例子&lt;/p&gt;
&lt;p&gt;假设我们有一个句子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;I love machine learning.&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们希望将其中的单词转换为向量表示（Embedding）。下面分别介绍三种方式：&lt;/p&gt;
&lt;h3 id="1-使用-word2vec-获取单词-embedding"&gt;&lt;strong&gt;1. 使用 Word2Vec 获取单词 Embedding&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;Word2Vec 通过上下文关系学习单词的语义，通常有 &lt;strong&gt;CBOW（Continuous Bag of Words）&lt;/strong&gt; 和 &lt;strong&gt;Skip-gram&lt;/strong&gt; 两种方式。假设我们使用了 Word2Vec 训练的预训练模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Word2Vec(&amp;quot;I&amp;quot;) → [0.12, -0.45, 0.88, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Word2Vec(&amp;quot;love&amp;quot;) → [-0.56, 0.77, -0.34, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Word2Vec(&amp;quot;machine&amp;quot;) → [0.67, -0.12, 0.45, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Word2Vec(&amp;quot;learning&amp;quot;) → [-0.23, 0.56, -0.78, ...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些向量是从大量文本中学习到的，可以用于 NLP 任务，比如情感分析、文本分类等。&lt;/p&gt;
&lt;h3 id="2-使用-glove-获取单词-embedding"&gt;&lt;strong&gt;2. 使用 GloVe 获取单词 Embedding&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;GloVe（Global Vectors for Word Representation）基于词共现矩阵构建词向量，它关注整个文本语料中词与词的共现关系。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GloVe(&amp;quot;I&amp;quot;) → [0.08, -0.34, 0.91, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GloVe(&amp;quot;love&amp;quot;) → [-0.63, 0.80, -0.25, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GloVe(&amp;quot;machine&amp;quot;) → [0.72, -0.10, 0.50, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GloVe(&amp;quot;learning&amp;quot;) → [-0.18, 0.50, -0.65, ...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GloVe 适用于静态的词向量训练，一旦训练完成，所有单词的表示不会随上下文变化。&lt;/p&gt;
&lt;h3 id="3-使用-transformer-训练得到单词-embedding"&gt;&lt;strong&gt;3. 使用 Transformer 训练得到单词 Embedding&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;在 Transformer 模型（如 BERT、GPT）中，单词 Embedding 是在 &lt;strong&gt;自注意力机制&lt;/strong&gt; 的作用下动态生成的。例如，在 BERT 预训练模型中，我们可以将句子输入到 BERT 中，得到动态的单词表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BERT(&amp;quot;I&amp;quot;) → [0.10, -0.22, 0.75, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BERT(&amp;quot;love&amp;quot;) → [-0.50, 0.70, -0.30, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BERT(&amp;quot;machine&amp;quot;) → [0.65, -0.15, 0.40, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BERT(&amp;quot;learning&amp;quot;) → [-0.20, 0.55, -0.70, ...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 Word2Vec 和 GloVe 不同，&lt;strong&gt;BERT 生成的单词向量会根据上下文变化&lt;/strong&gt;，例如“bank”在“river bank”（河岸）和“bank account”（银行账户）中的表示会不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Word2Vec 和 GloVe 生成的词向量是固定的，适用于大部分 NLP 任务。&lt;/li&gt;
&lt;li&gt;Transformer（如 BERT）生成的词向量是动态的，更适用于需要理解上下文的任务（如问答、文本生成）。
？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="位置embedding怎么表示"&gt;位置Embedding怎么表示？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;简介回答：公式计算&lt;/strong&gt;
&lt;img src="https://sleepman9.github.io/p/ai_model_transformer/image.png"
width="640"
height="136"
srcset="https://sleepman9.github.io/p/ai_model_transformer/image_hu_77f379bbb6b8026b.png 480w, https://sleepman9.github.io/p/ai_model_transformer/image_hu_6c9c64d4025d316d.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="470"
data-flex-basis="1129px"
&gt;&lt;/p&gt;
&lt;p&gt;假设我们有一个句子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;I love NLP models.&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Transformer 需要将这个句子转换为向量表示，其中包含单词的词向量（Word Embedding）和位置向量（Position Embedding）。假设我们使用 4 维的嵌入表示（为了简化示例），即每个单词的词向量和位置向量的维度均为 4。&lt;/p&gt;
&lt;h3 id="1-计算单词的-embeddingword-embedding"&gt;&lt;strong&gt;1. 计算单词的 Embedding（Word Embedding）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;假设使用预训练的 Word2Vec 或 Transformer 训练得到的单词嵌入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Embedding(&amp;quot;I&amp;quot;) = [0.1, 0.3, 0.5, 0.7]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Embedding(&amp;quot;love&amp;quot;) = [0.2, 0.4, 0.6, 0.8]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Embedding(&amp;quot;NLP&amp;quot;) = [0.3, 0.5, 0.7, 0.9]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Embedding(&amp;quot;models&amp;quot;) = [0.4, 0.6, 0.8, 1.0]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-计算位置-embeddingposition-embedding"&gt;&lt;strong&gt;2. 计算位置 Embedding（Position Embedding）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;按照 Transformer 提出的正弦/余弦公式计算位置编码（这里只是示例，实际计算会更复杂）：&lt;/p&gt;
&lt;p&gt;假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pos = 0&lt;/code&gt;（第一个单词 “I” 的位置），&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pos = 1&lt;/code&gt;（第二个单词 “love” 的位置），&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pos = 2&lt;/code&gt;（第三个单词 “NLP” 的位置），&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pos = 3&lt;/code&gt;（第四个单词 “models” 的位置）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用正弦和余弦函数计算的示例值（假设 4 维度 PE）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PE(0) = [sin(0), cos(0), sin(0/10000^(2/4)), cos(0/10000^(2/4))] = [0.0, 1.0, 0.0, 1.0]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PE(1) = [sin(1), cos(1), sin(1/10000^(2/4)), cos(1/10000^(2/4))] = [0.84, 0.54, 0.01, 0.99]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PE(2) = [sin(2), cos(2), sin(2/10000^(2/4)), cos(2/10000^(2/4))] = [0.91, -0.42, 0.02, 0.98]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PE(3) = [sin(3), cos(3), sin(3/10000^(2/4)), cos(3/10000^(2/4))] = [0.14, -0.99, 0.03, 0.97]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-计算最终的-transformer-输入"&gt;&lt;strong&gt;3. 计算最终的 Transformer 输入&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;将单词 Embedding 和位置 Embedding 相加，得到 Transformer 的输入向量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X(&amp;quot;I&amp;quot;) = [0.1, 0.3, 0.5, 0.7] + [0.0, 1.0, 0.0, 1.0] = [0.1, 1.3, 0.5, 1.7]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X(&amp;quot;love&amp;quot;) = [0.2, 0.4, 0.6, 0.8] + [0.84, 0.54, 0.01, 0.99] = [1.04, 0.94, 0.61, 1.79]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X(&amp;quot;NLP&amp;quot;) = [0.3, 0.5, 0.7, 0.9] + [0.91, -0.42, 0.02, 0.98] = [1.21, 0.08, 0.72, 1.88]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X(&amp;quot;models&amp;quot;) = [0.4, 0.6, 0.8, 1.0] + [0.14, -0.99, 0.03, 0.97] = [0.54, -0.39, 0.83, 1.97]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="4-解释"&gt;&lt;strong&gt;4. 解释&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;最终输入的向量 &lt;code&gt;X&lt;/code&gt; 结合了单词的语义信息（Word Embedding）和单词在句子中的顺序信息（Position Embedding）。这样 Transformer 在处理时就可以利用这些信息进行有效的注意力计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Word Embedding&lt;/strong&gt; 代表了单词的语义信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Position Embedding&lt;/strong&gt; 通过正弦和余弦函数编码位置，使模型能感知单词的顺序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二者相加&lt;/strong&gt; 形成 Transformer 的输入，使得模型在不使用 RNN 的情况下仍然能捕捉句子结构信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="encode是怎么工作的"&gt;Encode是怎么工作的？
&lt;/h2&gt;&lt;p&gt;内部&lt;code&gt;Multi-Head Attention&lt;/code&gt;，是由多个 &lt;code&gt;Self-Attention&lt;/code&gt;组成的。一些列的矩阵变换最终得到C矩阵。&lt;/p&gt;
&lt;h2 id="怎么得到c矩阵"&gt;怎么得到C矩阵？
&lt;/h2&gt;&lt;p&gt;上一个问题实际已经回答。&lt;/p&gt;
&lt;h2 id="c矩阵的内部信息是什么样的"&gt;C矩阵的内部信息是什么样的?
&lt;/h2&gt;&lt;p&gt;经过特殊编码，且的维度和原始矩阵X一致的输入信息。&lt;/p&gt;
&lt;h2 id="decode内部是怎么实现的"&gt;Decode内部是怎么实现的？
&lt;/h2&gt;&lt;p&gt;两个&lt;code&gt;Multi-Head Attention&lt;/code&gt;，第一个负责 &lt;code&gt;Masked&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="masked怎么实现"&gt;Masked怎么实现？
&lt;/h2&gt;&lt;p&gt;Mask矩阵，将数据掩盖。&lt;/p&gt;
&lt;h2 id="attention-机制是什么"&gt;Attention 机制是什么
&lt;/h2&gt;&lt;p&gt;大概意思就是让Encoder编码出的c向量跟Decoder解码过程中的每一个输出进行加权运算，在解码的每一个过程中调整权重取到不一样的c向量，更通俗的讲就是c 就是包含“欢迎来北京”这句话的意思，翻译到第一个词“welcome”的时候，需要着重去看“欢迎”这个词&lt;/p&gt;
&lt;p&gt;这里借用一个大佬说过的话：Attention听上去就是一个很屌，不明觉厉的东西，实际实现起来就是，哦原来是这么回事。总结一下吧，Attention机制就是让编码器编码出来的向量根据解码器要解码的东西动态变化的一种机制，貌似来源灵感就是人类视觉在看某一个东西的时候会有选择的针对重要的地方看。&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://zhuanlan.zhihu.com/p/194308943" target="_blank" rel="noopener"
&gt;Seq2Seq模型介绍&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;reference
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://zhuanlan.zhihu.com/p/338817680" target="_blank" rel="noopener"
&gt;Transformer模型详解（图解最完整版）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://mp.weixin.qq.com/s/WDq8tUpfiKHNC6y_8pgHoA" target="_blank" rel="noopener"
&gt;Transformer模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://zhuanlan.zhihu.com/p/403433120" target="_blank" rel="noopener"
&gt;Transformer代码详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.baihezi.com/post/224153.html" target="_blank" rel="noopener"
&gt;神经网络算法 – 一文搞懂 Transformer（总体架构 &amp;amp; 三种注意力层）&lt;/a&gt;&lt;/p&gt;</description></item><item><title>扫描链测试（scan chain）</title><link>https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/cover.png" alt="Featured image of post 扫描链测试（scan chain）" /&gt;&lt;h2 id="扫描链测试scan-chain"&gt;扫描链测试（scan chain）
&lt;/h2&gt;&lt;p&gt;在芯片功能设计完成后，整个网表是由一堆普通的寄存器和组合逻辑构成的。扫描链的插入就是指将普通寄存器替换成为扫描寄存器（scan flip-flop）的过程。&lt;/p&gt;
&lt;p&gt;SE scan enable为其切换信号。正常工作模式时，SE为0，这时scan FF的功能与原有的D-FF完全一致，data path 为D到Q。芯片的功能得以保持不变。当SE被切换为1时，这时候scan FF执行其scan属性，data path为SI到Q。SI即为测试时的数据流向入口。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image.png"
width="500"
height="224"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image_hu_cf54673001196058.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image_hu_59d7b13743d1e922.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="223"
data-flex-basis="535px"
&gt;&lt;/p&gt;
&lt;p&gt;Function         SE=0       datapath：D-&amp;gt;Q       scan FF act as DFF&lt;/p&gt;
&lt;p&gt;Scan               SE=1       datapath: SI-&amp;gt;Q       Scan FF act as Scan&lt;/p&gt;
&lt;p&gt;将片上的扫描寄存器Q-SI连接起来，就成为了扫描链。通过shift的方式可以由scan chain将数据串行输入的每个寄存器的SI端，达到控制每个寄存器的目的。在capture模式下，将芯片组合逻辑的反馈传回寄存器，达到对芯片内部观测的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-1.png"
width="447"
height="314"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-1_hu_9906b7906d9e30a3.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-1_hu_a29bc341eae0ad70.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="341px"
&gt;&lt;/p&gt;
&lt;h3 id="step-1"&gt;Step 1
&lt;/h3&gt;&lt;p&gt;DFT 第一步是做 scan chain，首先将电路中的普通 DFF 换成 scan DFF：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-2.png"
width="714"
height="249"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-2_hu_c85d2f36c0cdc86c.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-2_hu_625aeec730f6d0bc.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="286"
data-flex-basis="688px"
&gt;&lt;/p&gt;
&lt;p&gt;scan DFF 是在原DFF 的输入端增加了一个 MUX，于是多了几个 pin ：scan_in，scan_enable，scan_out&lt;/p&gt;
&lt;p&gt;换完之后将所有的 scan DFF 首尾依次串接起来，就构成了一条 scan chain ：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-3.png"
width="697"
height="216"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-3_hu_e8f5483829e4e1c6.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-3_hu_b8418e3b153a2ed8.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="774px"
&gt;&lt;/p&gt;
&lt;p&gt;当 SE 信号（即 scan enable ）有效时，电路进入scan 状态，此时数据通路如下图蓝色粗线所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-4.png"
width="679"
height="225"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-4_hu_8bf764e1878ea1c0.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-4_hu_2b978a9c1e543e1d.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="301"
data-flex-basis="724px"
&gt;&lt;/p&gt;
&lt;p&gt;当 SE 信号无效时，电路工作在 normal 状态，数据通路如下图红色粗线所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-5.png"
width="704"
height="241"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-5_hu_b963b9ca1aae0f69.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-5_hu_15421e1a6079f800.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="292"
data-flex-basis="701px"
&gt;&lt;/p&gt;
&lt;p&gt;那么，这样一条 scan chain 是如何检测到电路中的缺陷呢？&lt;/p&gt;
&lt;p&gt;简单来讲，scan chain 工作时分为三个步骤： load ····&amp;gt;  capture ····&amp;gt; unload&lt;/p&gt;
&lt;p&gt;load 是将input pattern 打入 scan chain&lt;/p&gt;
&lt;p&gt;capture 是将每一级组合逻辑的结果打入下一级register&lt;/p&gt;
&lt;p&gt;unload 是将scan chain 中的数据串行输出，得到 output pattern&lt;/p&gt;
&lt;p&gt;下图是一个简单的 scan chain 工作原理示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-6.png"
width="1500"
height="1019"
srcset="https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-6_hu_b468ea03b6c658ec.png 480w, https://sleepman9.github.io/p/%E6%89%AB%E6%8F%8F%E9%93%BE%E6%B5%8B%E8%AF%95scan-chain/image-6_hu_f166173df88855a9.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="353px"
&gt;&lt;/p&gt;
&lt;p&gt;结合上图，可知scan mode 的工作步骤如下：&lt;/p&gt;
&lt;p&gt;1. 将普通的 register 替换为 scan register&lt;/p&gt;
&lt;p&gt;2. 将 scan register 首尾依次串接起来&lt;/p&gt;
&lt;p&gt;3. 在 SE 有效拉高时，将 input pattern 串行打入scan register&lt;/p&gt;
&lt;p&gt;4. 然后 SE 拉低，等 Reg/Q 的值经过组合逻辑运算后到达下一级 reg 的D 端&lt;/p&gt;
&lt;p&gt;5. 再产生一个 capture pulse 将 D 端的值打入寄存器&lt;/p&gt;
&lt;p&gt;6. 最后 SE 拉高，将 reg 中的值依次串行输出，得到 output pattern&lt;/p&gt;
&lt;p&gt;7. 如果 output  pattern 和预期的输出结果相同，说明电路工作正常&lt;/p&gt;
&lt;h2 id="link"&gt;Link
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://vlsitutorials.com/dft-scan-and-atpg/" target="_blank" rel="noopener"
&gt;VLSI Tutorials&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.jianshu.com/p/b2ae98596801" target="_blank" rel="noopener"
&gt;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>IC_后端输入文件</title><link>https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/</link><pubDate>Wed, 27 Aug 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/</guid><description>&lt;h2 id="后端设计需要导入的设计文件"&gt;后端设计需要导入的设计文件
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;逻辑综合后的网表netlist（门级）&amp;mdash;-解决实现什么样的功能&lt;br&gt;
​&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825103724-g56889z.png"
width="663"
height="444"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825103724-g56889z_hu_137e590ba85e52c0.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825103724-g56889z_hu_1045f3bb187d769a.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
&gt;​&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;定义了大量与扫描链（scan chain）相关的信号，用于测试和调试。&lt;/li&gt;
&lt;li&gt;包含了用于时钟分频和复位处理的电路。&lt;/li&gt;
&lt;li&gt;实例化了子模块（如 mcore 和 proc），可能构成了一个完整的处理器或系统核心。&lt;/li&gt;
&lt;li&gt;涉及 AHB 总线接口、数据传输和控制信号的传递和管理。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;p&gt;lef文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;lef 和 def 区别：&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;lef:只告诉你“元器件长什么样、能放哪、怎么连”&lt;/p&gt;
&lt;p&gt;元器件的物理规则和抽象几何模型&lt;/p&gt;
&lt;p&gt;可以理解为：&lt;strong&gt;LEF&lt;/strong&gt; &lt;strong&gt;=&lt;/strong&gt; &lt;strong&gt;Cell/工艺的物理蓝图 + 设计规则&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;def：&lt;/p&gt;
&lt;p&gt;设计中元器件的放置和布线实现&lt;/p&gt;
&lt;p&gt;可以理解为：&lt;strong&gt;DEF&lt;/strong&gt; &lt;strong&gt;=&lt;/strong&gt; &lt;strong&gt;你的设计的实际布局布线结果&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;
&lt;p&gt;lib文件：std的属性&lt;br&gt;
​&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105054-lf9lfqe.png"
width="698"
height="485"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105054-lf9lfqe_hu_69e11e6a551b2f5c.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105054-lf9lfqe_hu_534262c662fbaa76.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="345px"
&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;timing libraries&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105539-vhgfwp0.png"
width="529"
height="203"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105539-vhgfwp0_hu_e263c146189d7aa7.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105539-vhgfwp0_hu_cbf81882992d27ad.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="260"
data-flex-basis="625px"
&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;timing constraints（SDC）&lt;br&gt;
​&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105707-htzsbb7.png"
width="676"
height="65"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105707-htzsbb7_hu_68acadcfd460e4f4.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105707-htzsbb7_hu_56c4deee82cc6598.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="1040"
data-flex-basis="2496px"
&gt;​&lt;/p&gt;
&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105756-ba2b9du.png"
width="681"
height="537"
srcset="https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105756-ba2b9du_hu_5bf24e7101061525.png 480w, https://sleepman9.github.io/p/ic_%E5%90%8E%E7%AB%AF%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/assets/image-20250825105756-ba2b9du_hu_69d57bab74ef36c7.png 1024w"
loading="lazy"
alt="image"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="304px"
&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="clock-tree-debug"&gt;clock tree debug
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://www.jianshu.com/p/1e84d86ab3c7" target="_blank" rel="noopener"
&gt;Clock Tree Debugger&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Job</title><link>https://sleepman9.github.io/p/job/</link><pubDate>Mon, 04 Aug 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/job/</guid><description>&lt;h2 id="前端"&gt;前端
&lt;/h2&gt;&lt;h2 id="验证"&gt;验证
&lt;/h2&gt;&lt;h2 id="后端"&gt;后端
&lt;/h2&gt;&lt;h3 id="url"&gt;URL
&lt;/h3&gt;&lt;p&gt;&lt;a class="link" href="https://www.nowcoder.com/discuss/353158032005734400" target="_blank" rel="noopener"
&gt;牛客———【数字IC后端岗】校招笔试如何准备？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="1什么是天线效应如何修复华为海思"&gt;1、什么是天线效应？如何修复？【华为海思】
&lt;/h3&gt;&lt;p&gt;（生产过程中）由于等离子刻蚀法使金属刻蚀过程中收集大量空间静电电荷，当金属积累的静电电荷超过一定数量，形成的电势超过它所接连门栅所能承受的击穿电压时，晶体管就会被击穿，导致器件损坏，这就是天线效应。&lt;/p&gt;
&lt;p&gt;在芯片生产过程中，暴露的金属线或者多晶硅（polysilicon）等导体，就象是一根根天线，会收集电荷（如等离子刻蚀产生的带电粒子）导致电位升高。天线越长，收集的电荷也就越多，电压就越高。若这片导体碰巧只接了MOS 的栅，那么高电压就可能把薄栅氧化层击穿，使电路失效，这种现象我们称之为“天线效应”。&lt;/p&gt;
&lt;p&gt;修复的方法:核心原理，释放天线上的电荷。&lt;br&gt;
&lt;a class="link" href="https://blog.csdn.net/qq_38328278/article/details/118544550#:~:text=%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20*%203.1%20%E8%B7%B3%E7%BA%BF%E6%B3%95%20%E5%B0%86%E6%9C%89%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E9%87%91%E5%B1%9E%E7%BA%BF%E6%89%93%E6%96%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E9%80%9A%E5%AD%94%E5%90%91%E4%B8%8A%E6%88%96%E5%90%91%E4%B8%8B%EF%BC%8C%E5%86%8D%E9%80%9A%E8%BF%87%E9%80%9A%E5%AD%94%E5%9B%9E%E5%88%B0%E8%AF%A5%E5%B1%82%E3%80%82%20%E8%B7%B3%E7%BA%BF%E7%BC%A9%E5%B0%8F%E4%BA%86%E9%87%91%E5%B1%9E%E8%BF%9E%E7%BA%BF%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%9B%A0%E8%80%8C%E8%B5%B7%E5%88%B0%E5%87%8F%E5%B0%8F%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82%20%E4%BD%86%E9%80%9A%E5%AD%94%E7%9A%84%E7%94%B5%E9%98%BB%E8%BE%83%E5%A4%A7%EF%BC%8C%E4%BC%9A%E5%BD%B1%E5%93%8D%E8%8A%AF%E7%89%87%E7%9A%84%E6%97%B6%E5%BA%8F%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AF%E8%83%BD%E5%9C%A8%E5%85%B6%E4%BB%96%E5%B1%82%E5%B8%A6%E6%9D%A5%E4%B8%B2%E6%89%B0%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82,%E7%A7%91%E5%AD%A6%E5%90%88%E7%90%86%E7%9A%84PCB%E8%AE%BE%E8%AE%A1%E9%9C%80%E4%BB%8E%E7%94%B5%E6%BA%90%E6%8E%A7%E5%88%B6%E5%85%A5%E6%89%8B%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%9B%9E%E6%B5%81%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%EF%BC%8C%E6%89%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%B7%B7%E5%90%88%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F%E3%80%82%20%E7%BB%A7%E7%BB%AD%E8%AE%BF%E9%97%AE%20%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E7%90%86%E5%8F%8A%E6%B6%88%E9%99%A4%E6%96%B9%E6%B3%95%20%E5%AF%BC%E8%AF%BB%EF%BC%9A%E9%9A%8F%E7%9D%80%E5%B7%A5%E8%89%BA%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%EF%BC%8C%E6%A0%85%E7%9A%84%E5%B0%BA%E5%AF%B8%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%B0%8F%EF%BC%8C%E9%87%91%E5%B1%9E%E7%9A%84%E5%B1%82%E6%95%B0%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%EF%BC%8C%E5%8F%91%E7%94%9F%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7%E5%B0%B1%E8%B6%8A%E5%A4%A7%E3%80%82%20%E8%80%8C%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E5%88%99%E4%BC%9A%E5%AF%B9%E5%B0%8F%E5%9E%8B%E6%8A%80%E6%9C%AF%E9%A2%86%E5%9F%9F%E4%BA%A7%E7%94%9F%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%B3%84%E7%94%B5%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%8D%9F%E5%AE%B3%E5%BE%88%E5%8F%AF%E8%83%BD%E6%B3%A2%E5%8F%8A%E6%95%B4%E4%B8%AA%E6%A0%85%E6%9E%81%E3%80%82%20%E5%9B%A0%E6%AD%A4%EF%BC%8C%E6%9C%AC%E6%96%87%E5%AF%B9%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9C%BA%E7%90%86%E5%8F%8A%E6%B6%88%E9%99%A4%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95%E5%81%9A%E5%87%BA%E4%BA%86%E8%AE%A8%E8%AE%BA%E3%80%82%201.%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%A4%A9%E7%BA%BF%E6%95%88%E5%BA%94%E6%88%96%E7%AD%89%E7%A6%BB%E5%AD%90%E5%AF%BC%E8%87%B4%E6%A0%85%E6%B0%A7%E6%8D%9F%E4%BC%A4%E6%98%AF%E6%8C%87%EF%BC%9A%E5%9C%A8MOS%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%B8%80%E7%A7%8D%E5%8F%AF%E6%BD%9C%E5%9C%A8%E5%BD%B1%E5%93%8D%E4%BA%A7%E5%93%81%E4%BA%A7%E9%87%8F%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E6%95%88%E5%BA%94%E3%80%82" target="_blank" rel="noopener"
&gt;天线效应产生原因及解决办法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（1）插入Diode二极管（保护二极管，反偏二极管）；
原理:在有天线效应的金属线上插入一个反向偏置的二极管。当金属线上积累的电荷达到一定程度时，二极管会导通(&amp;gt;0.7v)，形成到地的通路，从而释放积累的电荷，减少天线效应。&lt;/p&gt;
&lt;p&gt;优点:可以有效抑制电荷积累，降低天线效应。&lt;br&gt;
缺点:增加了芯片面积，不适用于大规模集成电路。&lt;/p&gt;
&lt;p&gt;（2）向上跳线法&lt;br&gt;
原理：跳线法通过打断有天线效应的金属线，然后通过通孔将其连接到其他金属层，再回到原层，以此来改变金属布线的长度和路径，从而降低天线效应。&lt;br&gt;
类型：跳线法主要分为向上跳线和向下跳线两种方式。向上跳线是将金属线连接到天线层上一层，向下跳线则连接到下一层。&lt;/p&gt;
&lt;p&gt;优点:相对简单，容易实现。&lt;br&gt;
缺点:通孔会增加电阻，可能影响芯片的时序和串扰问题。&lt;/p&gt;
&lt;p&gt;（3）size up cell&lt;br&gt;
原理：增加 cell 的栅极面积（denominator 增大）→ 减小天线比&lt;br&gt;
通过将原先的 cell 替换为更大版本的 cell（比如从 NAND2_X1 换成 NAND2_X4）：&lt;/p&gt;
&lt;p&gt;$ \text{Antenna Ratio} = \frac{\text{未连接金属的面积}}{\text{栅极面积}} $&lt;/p&gt;
&lt;p&gt;栅极面积增加（例如变成原来的 2 倍或 4 倍）；&lt;/p&gt;
&lt;p&gt;天线比自然降低，可能就会小于工艺允许的最大值；&lt;/p&gt;
&lt;p&gt;这样就避免了额外插入天线二极管、或断线、或插入 buffer 的复杂处理。&lt;/p&gt;
&lt;h3 id="2芯片tapeout前要做哪些检查华为海思"&gt;2、芯片tapeout前要做哪些检查？【华为海思】
&lt;/h3&gt;&lt;p&gt;时序（setup/hold）检查，后仿，DRC/LVS，电气规则检查ERC，DFM（可制造性设计），LEC（等价性检查）&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;点击展开所有详细信息&lt;/summary&gt;
&lt;p&gt;✅ 1. 时序检查（Setup/Hold）&lt;/p&gt;
&lt;p&gt;目的：确保芯片在工作频率下功能正确，不发生时序错误。&lt;/p&gt;
&lt;p&gt;• Setup 检查：确保数据在时钟边沿到来前已稳定，满足 最小建立时间 要求。&lt;br&gt;
• Hold 检查：确保数据在时钟边沿后仍保持足够时间不变，满足 保持时间 要求。&lt;br&gt;
• 采用 STA 工具（如 PrimeTime），在多个 PVT（工艺、供电、温度）条件下验证时序。&lt;br&gt;
• 执行 OCV、cross corner 分析及多模多库（MMMC）分析，增强时序可靠性。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 2. 后仿（Gate-level simulation with SDF）&lt;/p&gt;
&lt;p&gt;目的：验证综合、布局布线后，在真实延迟条件下芯片功能是否正确。&lt;/p&gt;
&lt;p&gt;• 生成 post-layout netlist 和时延文件（SDF）后执行门级仿真。&lt;br&gt;
• 验证异步复位、锁存器、启动序列、扫描链、低功耗控制等关键功能。&lt;br&gt;
• 检查 glitch、亚稳态及不可预测状态。&lt;br&gt;
• 包括 scan chain、ATPG 模式及功能全覆盖仿真。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 3. DRC（Design Rule Check）设计规则检查&lt;/p&gt;
&lt;p&gt;目的：确保芯片物理布局满足 Foundry 提供的制造工艺设计规则。&lt;/p&gt;
&lt;p&gt;• 检查项目：金属宽度、间距、过孔密度、器件间隔、TSV/Pad 限制等。&lt;br&gt;
• 通过 PDK 中的规则文件和工具（如 Calibre、IC Validator）自动检查。&lt;br&gt;
• 所有 DRC 错误必须 100% 修复，才能提交流片申请。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 4. LVS（Layout Versus Schematic）版图与原理图对比&lt;/p&gt;
&lt;p&gt;目的：确保最终版图与 RTL 描述的功能一致。&lt;/p&gt;
&lt;p&gt;• 核对版图中每个晶体管及连接是否与 netlist 匹配。&lt;br&gt;
• 避免误连、漏连和短接等错误。&lt;br&gt;
• 工具有 Calibre LVS 和 PVS LVS。&lt;br&gt;
• ECO 修改后需重新进行 LVS 校验。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 5. ERC（Electrical Rule Check）电气规则检查&lt;/p&gt;
&lt;p&gt;目的：捕捉常见电气错误，如浮空输入、短路和电压兼容性问题。&lt;/p&gt;
&lt;p&gt;• 常见检查：&lt;br&gt;
  – 输入未驱动或浮空；&lt;br&gt;
  – 电源与地的短接；&lt;br&gt;
  – 跨电压域连接（需使用隔离 cell）；&lt;br&gt;
  – IO 驱动中的电压不匹配。&lt;br&gt;
• 对低功耗设计（多电压/多电源域）尤为重要。&lt;br&gt;
• 常用工具包括 Calibre ERC 和 Synopsys IC Validator。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 6. DFM（Design for Manufacturability）可制造性检查&lt;/p&gt;
&lt;p&gt;目的：提升芯片良率和生产可控性，预防制造缺陷。&lt;/p&gt;
&lt;p&gt;• 包含检查：&lt;br&gt;
  – 密度检查（metal density / slotting）；&lt;br&gt;
  – 填充检查（dummy fill）；&lt;br&gt;
  – 边缘放置错误；&lt;br&gt;
  – 光刻热点检测。&lt;br&gt;
• 根据 DFM 报告，工厂会反馈是否需要调整设计。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;✅ 7. LEC（Logic Equivalence Check）等价性检查&lt;/p&gt;
&lt;p&gt;目的：确保综合后的 gate-level netlist 与 RTL 功能完全等价。&lt;/p&gt;
&lt;p&gt;• 检查流程：&lt;br&gt;
  – 比较 RTL（黄金模型）和 gate-level netlist（目标模型）的输入、输出及逻辑路径。&lt;br&gt;
• 应用于综合后验证、ECO 及 Scan 插入后验证。&lt;br&gt;
• 常用工具：Cadence Conformal、Synopsys Formality。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;补充性检查&lt;/p&gt;
&lt;p&gt;检查项 说明&lt;br&gt;
────────────────────────&lt;br&gt;
IR Drop 分析 检查供电网络是否存在过大的电压下降，防止功能异常。&lt;br&gt;
EM（电迁移）分析 检查金属线因电流过大而可能出现的迁移问题。&lt;br&gt;
Crosstalk / SI 分析 分析耦合电容引起的时序干扰。&lt;br&gt;
Antenna Check 检查天线效应，判断是否需要增加 diode 或断开连接。&lt;br&gt;
Package/IO Check 验证 IO 电压、电流是否符合 Pad 规则以及电源完整性。&lt;/p&gt;
&lt;p&gt;────────────────────────&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;华为海思等先进芯片设计公司在 Tapeout 前必须确保以下几点：&lt;br&gt;
功能正确（LEC、后仿） + 时序正确（STA） + 物理可靠（DRC/LVS/ERC/DFM） + 电气完整（IR Drop、EM、SI） + 制造可行（DFM）。&lt;/p&gt;
&lt;p&gt;缺一不可，否则可能导致芯片白流（白片）和巨额损失。如果在流程中的任何工具或步骤遇到问题，请提供具体日志或报错信息，以便进一步分析解决。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="3闩锁效应是什么怎么产生如何解决格科微"&gt;3、闩锁效应是什么，怎么产生如何解决？【格科微】
&lt;/h3&gt;&lt;p&gt;闩锁效应是CMOS工艺所特有的寄生效应，是指在芯片的电源和地之间存在一个低阻抗的通路，产生很大的电流，导致电路无法正常工作，甚至烧毁电路。严重会导致电路的失效，甚至烧毁芯片。闩锁效应是由NMOS的有源区、P衬底、N阱、PMOS的有源区构成的n-p-n-p结构产生的，当其中一个三极管正偏时，就会构成正反馈形成闩锁。避免闩锁的方法就是要减小衬底和N阱的寄生电阻，使寄生的三极管不会处于正偏状态&lt;/p&gt;
&lt;h3 id="4前后端的整个flow以及每一个步骤中会用到的工具芯原"&gt;4、前后端的整个flow，以及每一个步骤中会用到的工具【芯原】
&lt;/h3&gt;&lt;p&gt;前端：
（1）规格制定
芯片规格，也就像功能列表一样，是客户向芯片设计公司（称为 Fabless，无晶圆设计公司）提出的设计要求，包括芯片需要达到的具体功能和性能方面的要求。
（2）详细设计
Fabless根据客户提出的规格要求，拿出设计解决方案和具体实现架构，划分模块功能。&lt;/p&gt;
&lt;p&gt;（3）HDL编码
使用硬件描述语言（VHDL，Verilog HDL，业界公司一般都是使用后者）将模块功能以代码来描述实现，也就是将实际的硬件电路功能通过 HDL语言描述出来，形成 RTL（寄存器传输级）代码。&lt;/p&gt;
&lt;p&gt;（4）仿真验证
仿真验证就是检验编码设计的正确性，检验的标准就是（1）中制定的规格。看设计是否精确地满足了规格中的所有要求。规格是设计正确与否的黄金标准，一切违反，不符合规格要求的，就需要重新修改设计和编码。设计和仿真验证是反复迭代的过程，直到验证结果显示完全符合规格标准。
仿真验证工具 Synopsys 的VCS，还有Cadence的NC-Verilog。&lt;/p&gt;
&lt;p&gt;（5）逻辑综合――Design Compiler
仿真验证通过，进行逻辑综合。逻辑综合的结果就是把设计实现的 HDL代码翻译成门级网表 netlist。综合需要设定约束条件，就是你希望综合出来的电路在面积，时序等目标参数上达到的标准。逻辑综合需要基于特定的综合库，不同的库中，门电路基本标准单元（standard cell）的面积，时序参数是不一样的。所以，选用的综合库不一样，综合出来的电路在时序，面积上是有差异的。 一般来说，综合完成后需要再次做仿真验证（这个也称为后仿真，之前的称为前仿真）
逻辑综合工具 Synopsys 的 Design Compiler。&lt;/p&gt;
&lt;p&gt;（6）STA
Static Timing Analysis（STA），静态时序分析，这也属于验证范畴，它主要是在时序上对电路进行验证，检查电路是否存在建立时间（setup time）和保持时间（hold time）的违例（violation） 。这个是数字电路基础知识，一个寄存器出现这两个时序违例时，是没有办法正确采样数据和输出数据的，所以以寄存器为基础的数字芯片功能肯定会出现问题。
STA工具有Synopsys 的Prime Time。&lt;/p&gt;
&lt;p&gt;（7）形式验证
这也是验证范畴，它是从功能上（STA 是时序上）对综合后的网表进行验证。常用的就是等价性检查方法，以功能验证后的 HDL 设计为参考，对比综合后的网表功能，他们是否在功能上存在等价性。这样做是为了保证在逻辑综合过程中没有改变原先 HDL描述的电路功能。
形式验证工具有 Synopsys 的Formality。&lt;/p&gt;
&lt;p&gt;前端设计的流程暂时写到这里。从设计程度上来讲，前端设计的结果就是得到了芯片的门级网表电路。&lt;/p&gt;
&lt;p&gt;后端：
（1）DFT
Design For Test，可测性设计。芯片内部往往都自带测试电路，DFT的目的就是在设计的时候就考虑将来的测试。DFT的常见方法就是，在设计中插入扫描链，将非扫描单元（如寄存器）变为扫描单元。关于 DFT，有些书上有详细介绍，对照图片就好理解一点。 DFT
工具 Synopsys 的DFT Compiler&lt;/p&gt;
&lt;p&gt;（2）布局规划(FloorPlan)
布局规划就是放置芯片的宏单元模块，在总体上确定各种功能电路的摆放位置，如 IP模块，RAM，I/O引脚等等。布局规划能直接影响芯片最终的面积。&lt;/p&gt;
&lt;p&gt;（3）CTS
Clock Tree Synthesis，时钟树综合，简单点说就是时钟的布线。由于时钟信号在数字芯片的全局指挥作用，它的分布应该是对称式的连到各个寄存器单元，从而使时钟从同一个时钟源到达各个寄存器时，时钟延迟差异最小。这也是为什么时钟信号需要单独布线的原因。&lt;/p&gt;
&lt;p&gt;（4）布线(Place &amp;amp; Route)
这里的布线就是普通信号布线了，包括各种标准单元（基本逻辑门电路）之间的走线。比如我们平常听到的 0.13um 工艺，或者说 90nm 工艺，实际上就是这里金属布线可以达到的最小宽度，从微观上看就是MOS管的沟道长度。
2-4的工具有Synopsys的ICC/ICC2和Cadence的Innovus&lt;/p&gt;
&lt;p&gt;（5）版图物理验证
对完成布线的物理版图进行功能和时序上的验证，验证项目很多，如 LVS（Layout Vs Schematic）验证，简单说，就是版图与逻辑综合后的门级电路图的对比验证；DRC（Design Rule Checking） ：设计规则检查，检查连线间距，连线宽度等是否满足工艺要求ERC（Electrical Rule Checking） ：电气规则检查，检查短路和开路等电气 规则违例；等等。
工具为Mentor的calibre&lt;/p&gt;
&lt;p&gt;（6）寄生参数提取
由于导线本身存在的电阻，相邻导线之间的互感,耦合电容在芯片内部会产生信号噪声，串扰和反射。这些效应会产生信号完整性问题，导致信号电压波动和变化，如果严重就会导致信号失真错误。提取寄生参数进行再次的分析验证，分析信号完整性问题是非常重要的。
工具 Synopsys的 Star-RCXT。
（7） STA
（8） post-simulation(前仿是功能仿真，后仿真需要考虑门和线延迟)，动态时序仿真，是对加入了延时信息的网表文件进行的仿真，目的是验证时序以及功能都正确。它主要应用在异步逻辑、多周期路径、错误路径的验证中。需要布局布线后生成的网表文件.v和SDF文件.sdf。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;点击展开所有详细信息&lt;/summary&gt;
前端和后端设计流程是芯片设计（特别是数字IC）的两个主要阶段。以下是整个 flow 的详细分解，并列出了每一步常用的工具：
&lt;hr&gt;
&lt;p&gt;💡 一、前端设计流程（Front-End）&lt;/p&gt;
&lt;p&gt;前端主要关注芯片的功能实现和时序验证，通常基于 RTL（寄存器传输级）代码。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;内容描述&lt;/th&gt;
&lt;th&gt;常用工具&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. 规格定义（Spec）&lt;/td&gt;
&lt;td&gt;定义芯片的功能、性能、功耗、接口等需求&lt;/td&gt;
&lt;td&gt;Word / Excel / 文档工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 架构设计&lt;/td&gt;
&lt;td&gt;定义模块划分、通信方式、时钟域、功耗域等&lt;/td&gt;
&lt;td&gt;手动设计、Visio / Draw.io&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. RTL 编码&lt;/td&gt;
&lt;td&gt;使用 Verilog / VHDL 进行功能逻辑描述&lt;/td&gt;
&lt;td&gt;VSCode, VIM, Emacs, Vivado, Design Compiler（用于综合前检查）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4. 功能仿真（Simulation）&lt;/td&gt;
&lt;td&gt;使用 Testbench 验证 RTL 是否符合功能需求&lt;/td&gt;
&lt;td&gt;ModelSim, VCS, XSIM, Riviera-PRO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5. 形式验证（Formal）&lt;/td&gt;
&lt;td&gt;静态方式验证 RTL 是否存在死锁、冲突等逻辑问题&lt;/td&gt;
&lt;td&gt;JasperGold, VC Formal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6. 时序约束编写&lt;/td&gt;
&lt;td&gt;编写 .sdc（Synopsys Design Constraints）时序约束&lt;/td&gt;
&lt;td&gt;手写 or 使用工具生成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7. RTL 综合（Synthesis）&lt;/td&gt;
&lt;td&gt;将 RTL 转换成门级网表（Gate-level Netlist）&lt;/td&gt;
&lt;td&gt;Synopsys Design Compiler, Cadence Genus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8. 功能等价验证（LEC）&lt;/td&gt;
&lt;td&gt;验证综合后的网表与原始 RTL 是否等价&lt;/td&gt;
&lt;td&gt;Conformal LEC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;🛠️ 二、后端设计流程（Back-End）&lt;/p&gt;
&lt;p&gt;后端主要关注芯片物理实现，保证其在物理上可行并满足性能要求。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;内容描述&lt;/th&gt;
&lt;th&gt;常用工具&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. Floorplan（平面图）&lt;/td&gt;
&lt;td&gt;芯片初始布局，决定核心区域、IO 放置等&lt;/td&gt;
&lt;td&gt;Innovus, ICC2, Aprisa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. Power Planning&lt;/td&gt;
&lt;td&gt;电源网络设计，如 VDD/VSS 分布、power ring 等&lt;/td&gt;
&lt;td&gt;Innovus, RedHawk（IR drop 分析）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. Placement（布局）&lt;/td&gt;
&lt;td&gt;把门级网表中的单元在芯片上进行物理位置布局&lt;/td&gt;
&lt;td&gt;Innovus, ICC2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4. CTS（时钟树综合）&lt;/td&gt;
&lt;td&gt;构建稳定的时钟网络，使所有单元得到同步时钟&lt;/td&gt;
&lt;td&gt;Innovus CTS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5. Routing（布线）&lt;/td&gt;
&lt;td&gt;连接所有逻辑单元引脚，并满足 DRC、timing 等约束&lt;/td&gt;
&lt;td&gt;Innovus, ICC2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6. 时序分析 STA&lt;/td&gt;
&lt;td&gt;静态时序分析，检查 setup/hold violations&lt;/td&gt;
&lt;td&gt;PrimeTime, Tempus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7. DRC（版图规则检查）&lt;/td&gt;
&lt;td&gt;确保物理布局满足制造工艺的规则&lt;/td&gt;
&lt;td&gt;Calibre, Pegasus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8. LVS（电路布局一致性）&lt;/td&gt;
&lt;td&gt;比较网表与版图，确保物理布局和逻辑一致&lt;/td&gt;
&lt;td&gt;Calibre LVS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9. IR drop / EM 分析&lt;/td&gt;
&lt;td&gt;电源完整性分析，检查电压下降和电迁移等问题&lt;/td&gt;
&lt;td&gt;RedHawk, Voltus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10. 寄生参数提取（PEX）&lt;/td&gt;
&lt;td&gt;从布线中提取电容、电阻信息，用于后仿和时序分析&lt;/td&gt;
&lt;td&gt;StarRC, QRC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11. 后仿（Gate-level sim）&lt;/td&gt;
&lt;td&gt;含寄生的门级网表后仿，验证综合后逻辑功能及时序&lt;/td&gt;
&lt;td&gt;VCS, ModelSim&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12. ECO（工程变更）&lt;/td&gt;
&lt;td&gt;在物理设计完成后，对逻辑功能进行修改&lt;/td&gt;
&lt;td&gt;ECO 工具 + 手动 + LEC 校验&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13. GDSII 导出（流片数据）&lt;/td&gt;
&lt;td&gt;生成最终 GDS 文件，提供给 Foundry 进行制造&lt;/td&gt;
&lt;td&gt;Innovus, ICC2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;📦 三、Tape-out 前检查清单&lt;/p&gt;
&lt;p&gt;在正式流片之前，需完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;✅ STA 时序收敛&lt;/li&gt;
&lt;li&gt;✅ DRC 无错误&lt;/li&gt;
&lt;li&gt;✅ LVS 正确&lt;/li&gt;
&lt;li&gt;✅ 功能仿真通过（后仿）&lt;/li&gt;
&lt;li&gt;✅ ERC 电气规则检查&lt;/li&gt;
&lt;li&gt;✅ LEC 等价性检查&lt;/li&gt;
&lt;li&gt;✅ DFM 检查（可制造性分析）&lt;/li&gt;
&lt;li&gt;✅ Sign-off 签核（IR drop, EM, 功耗）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如需我为你输出一份“流程图”或“文档版清单”，也可以告诉我。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="5低功耗设计方法华为海思"&gt;5、低功耗设计方法【华为海思】
&lt;/h3&gt;&lt;p&gt;前端来讲：
（1）采用合适的编码算法&lt;br&gt;
（2）门控时钟&lt;br&gt;
（3）操作数隔离技术&lt;br&gt;
（4）综合中：相位分配，引脚互换，插入缓冲器&lt;br&gt;
（5）多阈值单元，非关键路径上采用高阈值器件，对于关键路径上，采用的是低阈值器件。&lt;br&gt;
后端上来讲：对于设计中翻转频繁的节点，采用低电容金属层布线。尽量缩短翻转率高的线长。采用低功耗为目的时钟树。&lt;br&gt;
（1）静态功耗: a. 在非关键路径用HVT cell； b. power shutfown c. 减少decap cell d. 降温散热；&lt;br&gt;
（2）动态功耗：a. 降压；b. 限制transition time c. 非关键时钟降频；d. 高频信号减少线长；e, 体偏置；f. 非关键路径用HVT Cell；g. MSMV；h. power domain；i. DVFS；j. clock gating；k. power gating&lt;/p&gt;
&lt;h3 id="6芯片的漏电和下面哪些因素有关bcd-大疆"&gt;6、芯片的漏电和下面哪些因素有关（BCD） 【大疆】
&lt;/h3&gt;&lt;p&gt;A 频率 B 电压 C温度 D 工艺&lt;br&gt;
解析：影响漏电流的因素: (1)工艺；(2)电压；(3)温度(温度越高，阈值电压Vth越小)，没有频率(影响动态功耗)&lt;/p&gt;
&lt;h3 id="7以下哪些变化存在功耗消耗abcd-大疆"&gt;7、以下哪些变化存在功耗消耗（ABCD） 【大疆】
&lt;/h3&gt;&lt;p&gt;A只有数据信号翻转 B只有复位信号翻转&lt;br&gt;
C只有时钟信号翻转 D所以信号都不翻转&lt;br&gt;
解析：不翻转也有静态功耗&lt;/p&gt;
&lt;h3 id="8消除噪声的方法-amd"&gt;8、消除噪声的方法 【AMD】
&lt;/h3&gt;&lt;p&gt;消除噪声的方法:&lt;br&gt;
(1) Shielding (2) Deep n-well (3) Isolating a block (4) guard ring&lt;/p&gt;
&lt;h3 id="9设计门电路实现以下波形-联发科"&gt;9、设计门电路实现以下波形。 【联发科】
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/job/assert/image.png"
width="315"
height="80"
srcset="https://sleepman9.github.io/p/job/assert/image_hu_ae61efcb8ce55d63.png 480w, https://sleepman9.github.io/p/job/assert/image_hu_13c3018923b390ef.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="393"
data-flex-basis="945px"
&gt;&lt;br&gt;
&lt;img src="https://sleepman9.github.io/p/job/assert/image-1.png"
width="510"
height="165"
srcset="https://sleepman9.github.io/p/job/assert/image-1_hu_f15641718ea9cc.png 480w, https://sleepman9.github.io/p/job/assert/image-1_hu_a5ee1e6582f780fd.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="309"
data-flex-basis="741px"
&gt;&lt;/p&gt;
&lt;p&gt;解析：先设计一个2分频电路，然后再用clk_in的低电平把二分频的波形过滤一下即可。&lt;/p&gt;
&lt;h3 id="10关于跨时钟域电路的设计以下说法正确的是d-乐鑫提前批"&gt;10、关于跨时钟域电路的设计，以下说法正确的是（D） 【乐鑫提前批】
&lt;/h3&gt;&lt;p&gt;A: 信号经两级D触发器同步后即可进行跨时钟域传递
B: 跨时钟域电路存在亚稳态风险，应当避免使用
C: 跨时钟域电路中一定存在亚稳态
D: 采用单一时钟的电路也可能产生亚稳态
解析：单一时钟不满足setup/hold要求也会出现亚稳态的。&lt;/p&gt;
&lt;h3 id="11nand和nor-flash的主要区别是1nand中常存在坏块-2nand容量可以做到很大3nand写入速度比较快-4nor-flash读出速度比较快-乐鑫提前批"&gt;11、NAND和NOR Flash的主要区别是1.（NAND）中常存在坏块， 2.（NAND）容量可以做到很大，3.（NAND）写入速度比较快， 4.（NOR Flash）读出速度比较快。 【乐鑫提前批】
&lt;/h3&gt;&lt;p&gt;解析：NOR容量小，NAND容量大;NOR读速度快，NAND擦写速度快;NAND会出现坏区&lt;/p&gt;
&lt;h3 id="12可以正常工作的数字电路芯片中一定不存在亚稳态-错-大疆创新"&gt;12、可以正常工作的数字电路芯片中一定不存在亚稳态 (错) 【大疆创新】
&lt;/h3&gt;&lt;p&gt;解析：比如跨时域所用的两级触发器，第一级是会出现亚稳态的，第二级就得到消除。&lt;/p&gt;
&lt;h3 id="13关于网表仿真的描述正确的是d--大疆创新"&gt;13、关于网表仿真的描述正确的是：（D ） 【大疆创新】
&lt;/h3&gt;&lt;p&gt;A 为了保证芯片的正常工作，即使在时间和资源紧张的情况下，也需要将所有RTL仿真用例都进行网表仿真并且确保通过&lt;br&gt;
B 网表仿真的速度比RTL仿真的速度更快&lt;br&gt;
C 网表仿真不能发现实现约束的问题&lt;br&gt;
D 网表仿真可以发现电路设计中的异步问题&lt;br&gt;
解析：网表仿真：通过网表反标标准延时格式文件（SDF）进行仿真，仿真速度较RTL仿真慢，由于标准延时格式文件通过SDC约束和单元逻辑延时和线网延时而来，可以发现约束问题
如果设计的规模较大的话，网表仿真所耗费的时间就比较长（所以B选项错误），所以常采用形式验证手段来保证门级网表在功能上与RTL设计保持一致（所以A选项错误），配合静态时序分析工具保证门级网表的时序。网表仿真中的门级仿真可以发现异步问题（所以D选项正确）。&lt;/p&gt;
&lt;h3 id="14sdf文件在ic哪个阶段使用文件包含了哪些信息-复旦微"&gt;14、SDF文件在IC哪个阶段使用？文件包含了哪些信息？ 【复旦微】
&lt;/h3&gt;&lt;p&gt;答：静态时序分析和后仿真(前仿真是功能仿真，时序为理想；而后仿真包含时序信息，会包含时序验证)。后仿的时候通过反标SDF得到真正的时序信息。
SDF包含了线延时和单元门延时。&lt;/p&gt;
&lt;h3 id="15请解释一下d触发器和latch的区别请解释一下同步复位和异步复位的区别及优缺点-联芸"&gt;15、请解释一下D触发器和latch的区别。请解释一下同步复位和异步复位的区别及优缺点。 【联芸】
&lt;/h3&gt;&lt;p&gt;(1) latch锁存器: 电平触发。当使能信号有效时通路，相反无效时保持输出。容易产生毛刺。门级电路latch消耗的资源少。但是如果在FPGA中，没有latch资源(有D触发器)，因此需要多个LE才能实现。&lt;br&gt;
(2) D触发器：边沿触发。仅在时钟有效沿到来时传递数据。不会产生毛刺。&lt;br&gt;
(3)同步复位：只有在时钟有效沿到来时，复位信号才起作用。优点: a. 有利于仿真器仿真； b. 使电路成为100%的同步时序电路，便于时序分析；c. 过滤毛刺。 缺点: a. 大多数库只有异步DFF，所以需要额外资源搭建同步复位DFF; b. 复位信号的宽度必须大于一个时钟周期。&lt;br&gt;
(4)异步复位：只要有复位信号就能马上复位。优点：a. 节省资源；b. 设计相对简单; 缺点: a. 复位信号易受到毛刺; b. 复位释放的时候容易出现亚稳态问题。&lt;/p&gt;
&lt;h3 id="16已知某种工艺商提供下面四种标准单元库hvt_c30-hvt_c40-lvt_c30-lvt_c40其中hvt表示high-threshold-voltagelvt表示low-threshold-voltagec30和c40表示channel-length数值的大小问哪种器件静态功耗有优势哪种器件的速度有优势-比特大陆"&gt;16、已知某种工艺商提供下面四种标准单元库，HVT_C30, HVT_C40, LVT_C30, LVT_C40，其中HVT表示high threshold voltage，LVT表示low threshold voltage，C30和C40表示channel length数值的大小。问：哪种器件静态功耗有优势？哪种器件的速度有优势？ 【比特大陆】
&lt;/h3&gt;&lt;p&gt;答：HVT_C40静态功耗有优势。因为阈值电压越高，沟道长度越长，漏电流越小。&lt;br&gt;
LVT_C30速度有优势，阈值电压越小，沟道长度越短，饱和电流越高。&lt;/p&gt;
&lt;h3 id="17why-power-stripes-routed-in-the-top-metal-layers"&gt;17.Why power stripes routed in the top metal layers?
&lt;/h3&gt;&lt;p&gt;为什么电源走线选用最上面的金属层？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：1&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;难度指数:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1:常识&amp;ndash;无论是否有工作经验，都应该准确回答&lt;br&gt;
2:简单&amp;ndash;只要做过一点后端的设计，就应该明白&lt;br&gt;
3:一般&amp;ndash;有实际工作经验一年左右，做过2个以上真正的设计，应该可以答上来&lt;br&gt;
4:较难&amp;ndash;在这个特定的领域有较多的研究，并积累了一定的经验&lt;br&gt;
5:很难&amp;ndash;基本上是专家级的牛人了！&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顶层金属层电阻最小，能承载更大电流，IR drop小。&lt;/li&gt;
&lt;li&gt;布线冲突最少，利于形成大面积电源网络,减少寄生电容和串扰。低层利用率较高，用来做power的话会占用一些有用的资源，比如std cell 通常是m1 Pin&lt;/li&gt;
&lt;li&gt;EM能力不一样，一般顶层是低层的2~3倍。更适合电源布线&lt;/li&gt;
&lt;li&gt;减小延迟（拥挤情况下走线长）与热量积累&lt;/li&gt;
&lt;li&gt;穿越多个模块/IP：上层金属能轻松跨越各个 IP block，实现供电覆盖。
反过来，底层的 IP block 通常不能被穿越，空间也更局限&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="18why-do-you-use-alternate-routing-approach-hvhvhv-horizontal-vertical-horizontal-vertical-horizontal-vertical"&gt;18.Why do you use alternate routing approach HVH/VHV (Horizontal-Vertical-Horizontal/ Vertical-Horizontal-Vertical)?
&lt;/h3&gt;&lt;p&gt;为什么要使用横竖交替的走线方式？ （感觉这个问题比较弱智，但是号称是intel的面试问题，晕！我憧憬和向往的圣地啊！！！）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：1&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少串扰（Crosstalk）干扰：交替的方向可以降低相邻金属层之间的电容耦合。如果两个相邻层都是同方向（比如都是水平方向），那么它们之间就容易产生电容耦合，导致信号干扰、延迟增加甚至信号完整性问题&lt;/li&gt;
&lt;li&gt;简化布线规则与提升可路由性，便于使用布线工具自动优化&lt;/li&gt;
&lt;li&gt;配合设计规则检查（DRC）更容易通过&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="19-how-to-fix-x-talk-violation"&gt;19. How to fix x-talk violation？
&lt;/h3&gt;&lt;p&gt;如何解决线间干扰？ (（应该至少有5大类解决办法，wire spacing, shielding, change layer之类的只算其中1类）)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：4&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;upsize victim net driver, downsize aggressor net driver&lt;/li&gt;
&lt;li&gt;increase wire space, shielding, change layer，change wire width&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Increase wire spacing：加大两根线之间的距离，降低寄生电容耦合。&lt;/p&gt;
&lt;p&gt;Shielding：在受害者与攻击者之间加接地/电源线，屏蔽电磁干扰。&lt;/p&gt;
&lt;p&gt;Change layer：换到耦合少的层（如低金属密度、厚介电层的层）。&lt;/p&gt;
&lt;p&gt;Change wire width：增宽导线可降低单位长度上的电阻和提高信号完整性&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;insert butter in victim net&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长线更易受串扰：导线越长，电容和电感耦合越大，串扰越严重&lt;/li&gt;
&lt;li&gt;插入缓冲器（Buffer）相当于将长导线分割成若干段，每段的耦合电容/电感减小，从而降低耦合强度，限制串扰传播范围。&lt;/li&gt;
&lt;li&gt;缓冲器是有源器件，它会重新驱动输出信号。&lt;/li&gt;
&lt;li&gt;上一级网络受到的串扰不会“直接传递”到下一级，因为缓冲器把其&lt;strong&gt;终止在当前级&lt;/strong&gt;，仅把自身输出给后面。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="4"&gt;
&lt;li&gt;把与victim net相连的输入端改成Hi-Vth的单元&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;高阈值电压单元对电压扰动的灵敏度较低，因此能更好地抗串扰；&lt;/p&gt;
&lt;p&gt;特别在输入端使用 Hi-Vth，可增加 noise margin。&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;改变信号的 timing window&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 aggressor 和 victim 的信号切换时序错开（即非重叠的时间窗口），即使存在耦合电容，也不会形成严重干扰&lt;/p&gt;
&lt;h3 id="20-what-would-you-do-in-order-to-not-use-certain-cells-from-the-library"&gt;20. What would you do in order to not use certain cells from the library?
&lt;/h3&gt;&lt;p&gt;如何禁止使用库里面的某些单元？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：1&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;禁用就用set_dont_use&lt;br&gt;
禁止修改就用set_dont_touch&lt;/p&gt;
&lt;h3 id="21-during-the-synthesis-what-type-of-wire-load-model-are-often-used"&gt;21. During the synthesis, what type of wire load model are often used?
&lt;/h3&gt;&lt;p&gt;做RTL综合时，经常使用的wire load model有哪几种？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：2&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在综合时，除了用ZWLM(zero wire load model)[]，或者不同K值的wire load model以外，还有一个基于物理位置（距离）的wire load model，在Cadence的RC中叫PLE，Synopsys叫DC Ultra Topographical&lt;/p&gt;
&lt;p&gt;背景：&lt;br&gt;
在数字电路设计中的 RTL 综合（RTL Synthesis） 过程中，Wire Load Models 用于估计信号传输时的延迟和功耗。这些模型通过将布线对电路的影响考虑进去，帮助综合工具做出合理的时序、面积和功耗优化决策。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;详细解释&lt;/summary&gt;
&lt;ol&gt;
&lt;li&gt;Zero Wire Load Model（ZWLM）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义：此模型假设所有的信号线都具有零的电容和延迟，即没有任何布线带来的电容影响。&lt;/p&gt;
&lt;p&gt;应用场景：通常用于早期设计阶段或当设计工具的目标是尽可能地减少信号的布线延迟影响时。由于这种模型没有考虑到布线电容，它适合用来做快速原型设计，但会导致计算出的时序不准确。&lt;/p&gt;
&lt;p&gt;优缺点：&lt;/p&gt;
&lt;p&gt;优点：计算速度快，适用于初步设计。&lt;/p&gt;
&lt;p&gt;缺点：不真实，因为电路中的布线总会带来一定的延迟和功耗。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;Traditional Wire Load Model（基于K值的WLM）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义：这种模型通过参数 K（通常是电容与信号长度或连接数量的比例）来估算布线电容。综合工具根据设计中的信号连接数量和布局来估算布线的电容和延迟。&lt;/p&gt;
&lt;p&gt;应用场景：适用于那些信号连接相对简单且布线关系较为规则的设计。这种模型假设电容是与布线长度或连接数量线性相关的。&lt;/p&gt;
&lt;p&gt;优缺点：&lt;/p&gt;
&lt;p&gt;优点：计算比较简单，适合一些常见的、规则化的设计。&lt;/p&gt;
&lt;p&gt;缺点：它不能精确考虑电路中复杂的布线结构，尤其是在设计中存在较大物理差异或布局时。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;Topographical Wire Load Model（基于物理位置的WLM）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义：该模型基于电路中的实际物理布局进行建模，考虑了布线的具体物理距离、层次结构和其他布局细节。在 Cadence 中称之为 PLE（Physical Layout Extraction），而在 Synopsys 中称之为 DC Ultra Topographical。&lt;/p&gt;
&lt;p&gt;应用场景：这种模型适用于高精度的设计，尤其是在复杂布局和大规模集成电路中。它能够考虑到每条信号线的具体物理长度、阻抗和电容，提供更为准确的时序分析和功耗估算。&lt;/p&gt;
&lt;p&gt;优缺点：&lt;/p&gt;
&lt;p&gt;优点：提供非常准确的估算，能够反映复杂布局的电容影响。&lt;/p&gt;
&lt;p&gt;缺点：计算开销大，需要更多的资源和时间进行模拟。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;ZWLM：假设没有布线影响，适用于快速估算，适合初步设计阶段。&lt;/p&gt;
&lt;p&gt;基于K值的WLM：适合常见的布线情况，计算简单但不精确。&lt;/p&gt;
&lt;p&gt;Topographical WLM：基于物理布局，最精确，但计算复杂，适用于精密设计和布局。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id="22-what-types-of-delay-model-are-used-in-digital-design-数字ic设计中有多少种类型的delay-model"&gt;22. What types of delay model are used in digital design? (数字IC设计中有多少种类型的delay model)
&lt;/h3&gt;&lt;p&gt;答案就是你说的“NLDM，CCS，和ECSM”，还有一个现在基本不用了的&amp;ndash;LDM&lt;/p&gt;
&lt;details&gt;
1. NLDM (Non-Linear Delay Model)
定义：非线性延迟模型（NLDM）考虑了信号传播的非线性特性，尤其是在较大负载或较长布线的情况下。它通过对延迟和电容之间的关系进行非线性拟合来计算延迟。
&lt;p&gt;特点：NLDM 通常用于高精度的延迟建模，特别是在复杂设计中，能够精确描述延迟与电容、负载的非线性关系。&lt;/p&gt;
&lt;p&gt;应用场景：适用于需要更高精度时序估算的复杂电路，特别是当负载较大或信号传播路径较长时。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;CCS (Constant Current Source Model)
定义：恒定电流源模型（CCS）假设每个门电路的驱动能力是常数，且与输入电压变化无关。CCS 延迟模型以恒定的电流源来描述门电路的电流驱动特性，并根据负载电容来计算延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：这种模型通过一个简化的电流源模型来估算门电路的延迟，适用于一些简单设计中的时序计算。&lt;/p&gt;
&lt;p&gt;应用场景：适用于电流驱动能力较为稳定、较简单的电路。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;ECSM (Elmore Delay Model)
定义：Elmore 延迟模型（ECSM）是一种基于 RC 网络的经典延迟模型，通过对电路中的电阻和电容进行加权计算，给出信号传播延迟的估算值。它通过 RC 等效电路分析信号的传输延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：ECSM 以 RC 网络的等效模型来计算延迟，比较简单并且计算速度较快，适用于较为规则的电路。&lt;/p&gt;
&lt;p&gt;应用场景：适用于大部分常规的数字电路设计，尤其在布线延迟较为均匀时使用广泛。&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;LDM (Linear Delay Model) — 已不常用
定义：线性延迟模型（LDM）假设延迟与电容之间的关系是线性的，即延迟与电容成正比。LDM 是最早期的延迟模型之一，已逐渐被更精确的模型所取代。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：LDM 模型计算简单，但没有考虑非线性效应，适用于非常简单的设计或不需要高精度估算的场合。&lt;/p&gt;
&lt;p&gt;应用场景：由于其简化的假设，现在几乎不再使用，特别是在现代复杂的数字设计中。&lt;/p&gt;
&lt;p&gt;总结：
NLDM：精确的非线性延迟模型，适用于复杂电路和高精度要求的设计。&lt;/p&gt;
&lt;p&gt;CCS：基于恒定电流源的模型，适用于简单设计和较为稳定的驱动能力。&lt;/p&gt;
&lt;p&gt;ECSM：基于 RC 网络的经典延迟模型，计算速度快，适用于大多数标准数字电路。&lt;/p&gt;
&lt;p&gt;LDM：已不常用，线性假设使得其在现代设计中精度不够。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;Wire Load Model (WLM) 和 Delay Model 都是数字设计中用于评估时序、延迟和功耗的工具，但它们有不同的关注点和计算方式。它们之间有一定的关系，但也有各自独立的作用。&lt;br&gt;
WLM 主要关注的是布线的电容特性，而 Delay Model 则更侧重于逻辑元件的延迟。它们相辅相成，WLM 提供了 Delay Model 需要的输入，而 Delay Model 通过这些输入来计算信号传播的延迟。&lt;/p&gt;
&lt;h3 id="23-how-delays-are-characterized-using-wlm-wire-load-model"&gt;23. How delays are characterized using WLM (Wire Load Model)?
&lt;/h3&gt;&lt;p&gt;使用一般的WLM （不是zero WLM，也不是按照物理位置算的DCT），DC是如何计算delay的？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：2&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;一条Timing path上的Delay有2部分组成，Cell Delay + NetDelay。&lt;br&gt;
在ＤＣ中，Net Delay应该来说就是有ＷＬＭ中得到的，而Cell Delay就是根据WLM中得到的input Tran跟Cell 的output load通过查表得到Cell delay。&lt;/p&gt;
&lt;p&gt;既然问的是如何使用WLM来计算延迟，那一定是net delay了，其实这是一个小坑，看你知道不知道WLM是用来计算什么的延迟。&lt;/p&gt;
&lt;p&gt;现在问题变得直接了，就是考你WLM的具体用法&amp;ndash;如何计算出net的R和C的？&lt;/p&gt;
&lt;p&gt;DC在计算延时的时候，主要根据输出的tansition 和net的RC值来计算。&lt;br&gt;
output tansition是由驱动cell的input tansition和load通过查表得到的&lt;br&gt;
而net的rc就要根据所选取的wrie load model来计算，计算时和输出的fanout决定&lt;/p&gt;
&lt;p&gt;以smic13的smic13_wl10为例
wire_load(&amp;ldquo;smic13_wl10&amp;rdquo;) {
resistance : 8.5e-8;
capacitance : 1.5e-4;
area : 0.7;
slope : 66.667;
fanout_length (1,66.667);}
根据fanout值，由fanout(1,66.667)可以得出互连线长度为66.667，然后根据resistance和capacitance计算出互连线电容为1.5e-4&lt;em&gt;66.667，互连线电阻为8.5e-8&lt;/em&gt;66.667
，当然如果扇出值表中没有，就会用到slope，例如扇出为3时，此时估算的互连线长度为1*66.667+（3-1）*slope，再计算出RC值，然后DC由此计算net的延时&lt;/p&gt;
&lt;h3 id="24there-are-source-clock-clka-create_clock-and-generated-clock-clkb-by-clka"&gt;24.There are source clock clka (create_clock), and generated clock clkb by clka.
&lt;/h3&gt;&lt;p&gt;In pre-CTS netlist, there is network latency in clka, how this latency propagates to clkb?
In post-CTS netlist, What you need to do for this network latency?&lt;/p&gt;
&lt;p&gt;假设有两个时钟，原始为clka，生成的时钟为clkb，
在没有时钟树的网表中，clka的network latency会自动传递到clkb上吗？clkb的latency如何描述？&lt;br&gt;
在生成时钟树的网表中，如何处理network latency? clkb的latency又如何描述？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：3&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;A：&lt;br&gt;
1）latency会自动传到clkb上&lt;br&gt;
2）去掉clock network latency，让工具自己算&lt;/p&gt;
&lt;h3 id="25there-are-source-clock-clka-create_clock-and-generated-clock-clkb-by-clka-how-do-you-specify-them-in-cts-spec-file-assume-there-is-real-timing-path-between-clka-and-clkb"&gt;25.There are source clock clka (create_clock), and generated clock clkb by clka. how do you specify them in CTS spec file? Assume there is real timing path between clka and clkb.
&lt;/h3&gt;&lt;p&gt;clkb是clka的生成时钟，在CTS的spec文件中如何定义这两个时钟？假设clka和clkb之间的FF有时序收敛的要求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度：3&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在CTS的spec文件中定义 clka 是 root，clkb 为 through pin，再加上那些应该有的skew，transition，insertion delay等就好了，
其它的事CTS会给你做&lt;/p&gt;
&lt;h3 id="26"&gt;26.
&lt;/h3&gt;</description></item><item><title>IC验证——UVM方法学</title><link>https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/</link><pubDate>Mon, 28 Jul 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/</guid><description>&lt;img src="https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/cover.png" alt="Featured image of post IC验证——UVM方法学" /&gt;&lt;h2 id="前言"&gt;前言
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;验证的本质：尽可能的找出设计的bug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证的3要素
(1)灌激励：输入信号
(2)集响应：输出信号
(3)作比较：比较&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="uvm实战张强"&gt;《uvm实战》&amp;ndash;张强
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/image.png"
width="1277"
height="652"
srcset="https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/image_hu_486d6b03ae9580d9.png 480w, https://sleepman9.github.io/p/ic%E9%AA%8C%E8%AF%81uvm%E6%96%B9%E6%B3%95%E5%AD%A6/image_hu_51186de42492e7a7.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="195"
data-flex-basis="470px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_41034231/article/details/108130501" target="_blank" rel="noopener"
&gt;UVM验证平台整体结构&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="基础介绍相关link"&gt;基础介绍相关link
&lt;/h2&gt;&lt;h2 id="books"&gt;Books
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://github.com/obugss/ebook" target="_blank" rel="noopener"
&gt;验证书籍&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ASIC全流程</title><link>https://sleepman9.github.io/p/asic%E5%85%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Sun, 20 Jul 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/asic%E5%85%A8%E6%B5%81%E7%A8%8B/</guid><description>&lt;img src="https://sleepman9.github.io/p/asic%E5%85%A8%E6%B5%81%E7%A8%8B/cover.png" alt="Featured image of post ASIC全流程" /&gt;&lt;h2 id="ic全流程"&gt;ic全流程
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;规格制定。频率，功耗，速度&lt;/li&gt;
&lt;li&gt;RTL设计。HDL描述逻辑Algorithm，类似于高级设计语言cpp，里面涉及低功耗设计方法&lt;/li&gt;
&lt;li&gt;功能仿真。逻辑代码是否正确，查看波形&lt;/li&gt;
&lt;li&gt;逻辑综合。将RTL代码转化为门级网表，里面包含时序约束，功耗约束，PPA优化&lt;/li&gt;
&lt;li&gt;STA。确保时钟⏰&lt;/li&gt;
&lt;li&gt;形式验证。比较RTL 代码逻辑功能是否和逻辑综合出来的门级网表功能一致&lt;/li&gt;
&lt;li&gt;门级仿真。&lt;/li&gt;
&lt;li&gt;DFT。在设计中加入测试结构，使芯片在生产后可以验证其功能正确性&lt;/li&gt;
&lt;li&gt;Floorplan&lt;/li&gt;
&lt;li&gt;place&lt;/li&gt;
&lt;li&gt;CTS&lt;/li&gt;
&lt;li&gt;route&lt;/li&gt;
&lt;li&gt;STA&lt;/li&gt;
&lt;li&gt;PI&lt;/li&gt;
&lt;li&gt;SI&lt;/li&gt;
&lt;li&gt;Low Power&lt;/li&gt;
&lt;li&gt;Signoff&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>人生思考</title><link>https://sleepman9.github.io/p/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/</link><pubDate>Thu, 24 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/</guid><description>&lt;blockquote&gt;
&lt;p&gt;万事万物一切都有&lt;strong&gt;套路&lt;/strong&gt;可循 &lt;br&gt;
先僵化，后优化，再固化 &amp;ndash;任正非&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;僵化：站在巨人的肩膀上：处于学习初期阶段的“削足适履”;&lt;/li&gt;
&lt;li&gt;优化：掌握自我批判武器：在实践中不断吸收、改良、创新，优化自己；&lt;/li&gt;
&lt;li&gt;固化：创新是有阶段性的、受约束的，如果没有约束，创新就是杂乱无章、无序的创新，需要像夯土一样，一层层夯上去，一步步固化阶段性的优化成果；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="面对未知领域怎么应对"&gt;面对未知领域怎么应对
&lt;/h2&gt;&lt;p&gt;快速把这个领域里的基本的、重要的背景知识了解、掌握。&lt;/p&gt;
&lt;p&gt;不要贪大求全，不要奢望把所有相关的内容都掌握，这是不可能的，尤其是在短时间内。我们的目标是把活做好，把项目完成。&lt;/p&gt;
&lt;h2 id="面对一件全新的工作怎么切入"&gt;面对一件全新的工作，怎么切入
&lt;/h2&gt;&lt;p&gt;！！！刚开始不要钻的太深！！！！&lt;/p&gt;
&lt;p&gt;一般的做法是：找套路！（有没有什么套路可循）&lt;/p&gt;</description></item><item><title>如何制定软件设计开发计划</title><link>https://sleepman9.github.io/p/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92/</link><pubDate>Thu, 24 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92/</guid><description>&lt;h2 id="架构分层分模块"&gt;架构分层，分模块
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://www.cnblogs.com/sewain/p/14497769.html" target="_blank" rel="noopener"
&gt;都说软件架构要分层、分模块，具体应该怎么做 一&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.cnblogs.com/sewain/p/14527392.html" target="_blank" rel="noopener"
&gt;都说软件架构要分层、分模块，具体应该怎么做 二&lt;/a&gt;&lt;/p&gt;</description></item><item><title>装机必备</title><link>https://sleepman9.github.io/p/%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/</link><pubDate>Thu, 17 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/</guid><description>&lt;h2 id="application"&gt;Application
&lt;/h2&gt;&lt;h3 id="vscode"&gt;Vscode
&lt;/h3&gt;&lt;p&gt;伟大的IDE(IDE 是 Integrated Development Environment 的缩写，中文叫做“集成开发环境”)&lt;/p&gt;</description></item><item><title>CLAP</title><link>https://sleepman9.github.io/p/clap/</link><pubDate>Wed, 16 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/clap/</guid><description>&lt;h2 id="clap-模型介绍"&gt;CLAP 模型介绍
&lt;/h2&gt;&lt;p&gt;CLAP（Contrastive Language-Audio Pretraining，对比语言-音频预训练）是一种跨模态深度学习模型，旨在通过对比学习（Contrastive Learning）将音频信号与自然语言描述对齐。其核心思想是让模型理解音频内容与文本描述之间的语义关联，从而实现音频分类、检索、生成等任务·&lt;/p&gt;</description></item><item><title>力扣碎碎念</title><link>https://sleepman9.github.io/p/%E5%8A%9B%E6%89%A3%E7%A2%8E%E7%A2%8E%E5%BF%B5/</link><pubDate>Wed, 16 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E5%8A%9B%E6%89%A3%E7%A2%8E%E7%A2%8E%E5%BF%B5/</guid><description>&lt;p&gt;&lt;a class="link" href="https://blog.algomooc.com/" target="_blank" rel="noopener"
&gt;吴师兄学算法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="为什么要使用引用-"&gt;为什么要使用引用 &amp;amp;
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&amp;amp;envId=top-100-liked" target="_blank" rel="noopener"
&gt;两数之和&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;twoSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 实现代码将在这里
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免不必要的拷贝&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不使用引用（&lt;code&gt;vector&amp;lt;int&amp;gt; nums&lt;/code&gt;），当传入大型数组时，C++ 会创建整个向量的完整副本&lt;/li&gt;
&lt;li&gt;使用引用（&lt;code&gt;vector&amp;lt;int&amp;gt;&amp;amp; nums&lt;/code&gt;）可以直接操作原始数据，不产生拷贝开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存效率&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于大型输入数组，拷贝会消耗大量内存和时间&lt;/li&gt;
&lt;li&gt;引用只是原始数据的别名（通常实现为指针），内存占用固定（通常4或8字节）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能优化&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用传递是O(1)时间复杂度&lt;/li&gt;
&lt;li&gt;值传递是O(n)时间复杂度（n为数组大小）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;允许修改原数据&lt;/strong&gt;（虽然本题不需要）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果函数需要修改输入数组，引用是必要的&lt;/li&gt;
&lt;li&gt;如果不想允许修改，可以用 &lt;code&gt;const vector&amp;lt;int&amp;gt;&amp;amp; nums&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;引用 vs 值传递的对比：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;引用传递 (&lt;code&gt;vector&amp;lt;int&amp;gt;&amp;amp;&lt;/code&gt;)&lt;/th&gt;
&lt;th&gt;值传递 (&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内存使用&lt;/td&gt;
&lt;td&gt;极小（仅引用）&lt;/td&gt;
&lt;td&gt;复制整个向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;时间复杂度&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;能否修改原数据&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不能（修改的是副本）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;大型数据结构&lt;/td&gt;
&lt;td&gt;小型或需要隔离的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在算法题目中，特别是输入规模可能很大的情况下，使用引用是更优的选择。&lt;/p&gt;
&lt;h2 id="十大经典排序算法动图演示"&gt;十大经典排序算法（动图演示）
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener"
&gt;十大经典排序算法（动图演示）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="设计模式"&gt;设计模式
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://www.yuque.com/nathan-kd4ra/soft_exam/yqqus1x0752qwt9y#70e53119" target="_blank" rel="noopener"
&gt;设计模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/weixin_45712636/article/details/124328504" target="_blank" rel="noopener"
&gt;C++设计模式（全23种）&lt;/a&gt;&lt;/p&gt;</description></item><item><title>网表相关</title><link>https://sleepman9.github.io/p/%E7%BD%91%E8%A1%A8%E7%9B%B8%E5%85%B3/</link><pubDate>Thu, 10 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E7%BD%91%E8%A1%A8%E7%9B%B8%E5%85%B3/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E7%BD%91%E8%A1%A8%E7%9B%B8%E5%85%B3/cover.png" alt="Featured image of post 网表相关" /&gt;&lt;h2 id="hspice-quick-reference-guide"&gt;HSPICE Quick Reference Guide
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://amarketplaceofideas.com/wp-content/uploads/2014/09/hspice_qr1.pdf" target="_blank" rel="noopener"
&gt;HSPICE Quick Reference Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://iccircle.com/static/upload/img20240809173315.pdf" target="_blank" rel="noopener"
&gt;HSPICE® User Guide: Basic Simulation and Analysis&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="网表求解的本质"&gt;网表求解的本质
&lt;/h2&gt;&lt;p&gt;网表求解的本质在于将电路中各个元件和它们的连接关系转化为数学方程（通常基于基尔霍夫定律和元件的本构关系），然后利用数值计算方法求解这些方程组，从而得到各个节点电压和支路电流等信息。简单来说，就是把电路“翻译”成数学问题，再使用求解器进行数值求解。&lt;/p&gt;
&lt;h2 id="不同仿真类型的的本质"&gt;不同仿真类型的的本质
&lt;/h2&gt;&lt;p&gt;不同仿真类型的本质都在于：将电路的物理行为转化为数学模型，然后求解相应的数学方程以获得电路在特定条件下的响应。不过，它们侧重关注的方面不同，具体说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直流工作点分析 (.op) 和直流扫描分析 (.DC)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直流工作点分析：求解电路在直流稳态下（没有时间变化因素）的电压、电流等参数。它的本质是求解一组非线性代数方程，确定电路各节点的静态工作状态。&lt;/p&gt;
&lt;p&gt;直流扫描分析：在直流工作点分析的基础上，通过改变一个或多个直流激励源（如电压或电流），观察器件或电路参数随偏置变化的趋势。其本质依然是求解静态非线性代数方程，但需要遍历一系列激励值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;瞬态分析 (.TRAN)
瞬态分析关注电路响应随时间的动态变化。它将电路描述为一组微分方程（可能还包含非线性部分），然后利用数值积分算法（如欧拉法、龙格-库塔法等）求解时间域响应，从而揭示电路在施加激励后随时间变化的动态行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交流小信号分析 (.AC)
该分析是在电路的直流工作点附近对电路进行线性化，转换到频率域求解。它的本质是将电路的非线性行为在小激励条件下近似为线性模型，通过求解复数域中的方程（使用如拉普拉斯变换或者直接建立导纳矩阵）得到电路的频率响应、相位特性等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之，无论是哪种仿真类型，基本思路都是“建立数学模型 – 数值求解 – 得到物理量”，只是不同的仿真关注于电路静态状态、动态响应或频率特性等不同方面。&lt;/p&gt;</description></item><item><title>SCP_传输文件</title><link>https://sleepman9.github.io/p/scp_%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</link><pubDate>Thu, 03 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/scp_%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</guid><description>&lt;p&gt;&lt;code&gt;scp&lt;/code&gt;（Secure Copy Protocol）用于在本地与远程服务器之间、或者两台远程服务器之间安全地复制文件。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="从本地复制到远程服务器"&gt;从本地复制到远程服务器
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp /path/to/local/file username@remote_host:/path/to/remote/directory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp myfile.txt user@192.168.1.100:/home/user/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这会将 &lt;code&gt;myfile.txt&lt;/code&gt; 复制到远程服务器 &lt;code&gt;192.168.1.100&lt;/code&gt; 的 &lt;code&gt;/home/user/&lt;/code&gt; 目录。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="从远程服务器复制到本地"&gt;从远程服务器复制到本地
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp username@remote_host:/path/to/remote/file /path/to/local/directory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp user@192.168.1.100:/home/user/myfile.txt /home/localuser/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这会把远程服务器 &lt;code&gt;/home/user/myfile.txt&lt;/code&gt; 复制到本地 &lt;code&gt;/home/localuser/&lt;/code&gt; 目录。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="复制整个文件夹加--r-选项"&gt;复制整个文件夹（加 &lt;code&gt;-r&lt;/code&gt; 选项）
&lt;/h2&gt;&lt;h3 id="本地--远程"&gt;本地 → 远程
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp -r /path/to/local/directory username@remote_host:/path/to/remote/directory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp -r myfolder user@192.168.1.100:/home/user/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;将 &lt;code&gt;myfolder&lt;/code&gt; 目录及其内容复制到远程服务器 &lt;code&gt;/home/user/&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="远程--本地"&gt;远程 → 本地
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp -r username@remote_host:/path/to/remote/directory /path/to/local/directory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp -r user@192.168.1.100:/home/user/myfolder /home/localuser/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;将远程服务器上的 &lt;code&gt;myfolder&lt;/code&gt; 复制到本地 &lt;code&gt;/home/localuser/&lt;/code&gt; 目录。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="从一台远程服务器复制到另一台远程服务器"&gt;从一台远程服务器复制到另一台远程服务器
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp username1@remote_host1:/path/to/file username2@remote_host2:/path/to/destination
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp user1@192.168.1.101:/home/user1/file.txt user2@192.168.1.102:/home/user2/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这会直接把 &lt;code&gt;192.168.1.101&lt;/code&gt; 上的 &lt;code&gt;file.txt&lt;/code&gt; 复制到 &lt;code&gt;192.168.1.102&lt;/code&gt; 上的 &lt;code&gt;/home/user2/&lt;/code&gt; 目录。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="指定端口-p-选项大写-p"&gt;指定端口（&lt;code&gt;-P&lt;/code&gt; 选项，大写 P）
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp -P &lt;span class="m"&gt;2222&lt;/span&gt; myfile.txt user@192.168.1.100:/home/user/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果远程服务器的 SSH 端口不是默认 &lt;code&gt;22&lt;/code&gt;，可以使用 &lt;code&gt;-P&lt;/code&gt; 指定端口，如 &lt;code&gt;2222&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="使用--c-启用压缩加速传输"&gt;使用 &lt;code&gt;-C&lt;/code&gt; 启用压缩加速传输
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp -C myfile.txt user@192.168.1.100:/home/user/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对于大文件或慢速网络，可以使用 &lt;code&gt;-C&lt;/code&gt; 进行压缩，提高传输效率。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="限制带宽-l-选项单位-kbits"&gt;限制带宽（&lt;code&gt;-l&lt;/code&gt; 选项，单位 Kbit/s）
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;scp -l &lt;span class="m"&gt;1000&lt;/span&gt; myfile.txt user@192.168.1.100:/home/user/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面命令限制最大带宽为 &lt;code&gt;1000 Kbit/s&lt;/code&gt;，即 &lt;code&gt;125 KB/s&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="总结"&gt;总结
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;需求&lt;/th&gt;
&lt;th&gt;命令示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;本地 → 远程&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scp file.txt user@remote:/home/user/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;远程 → 本地&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scp user@remote:/home/user/file.txt ./&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;复制文件夹&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scp -r folder user@remote:/home/user/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;远程 → 远程&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scp user1@host1:/file user2@host2:/dir/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;指定端口&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scp -P 2222 file user@remote:/home/user/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;启用压缩&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scp -C file user@remote:/home/user/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;限制带宽&lt;/td&gt;
&lt;td&gt;&lt;code&gt;scp -l 1000 file user@remote:/home/user/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;💡 &lt;strong&gt;&lt;code&gt;scp&lt;/code&gt; 适用于小型文件传输，大规模文件推荐 &lt;code&gt;rsync&lt;/code&gt; 进行增量传输！&lt;/strong&gt; 🚀&lt;/p&gt;</description></item><item><title>Vscode Debug</title><link>https://sleepman9.github.io/p/vscode-debug/</link><pubDate>Thu, 03 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/vscode-debug/</guid><description>&lt;p&gt;&lt;strong&gt;.vscode launch.json 调试设置&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 配置文件的版本号
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;#34;configurations&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;Python: Run run.py&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 配置的名称，用于在调试配置列表中标识此配置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;python&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 调试器的类型，这里使用的是 Python 调试器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;#34;request&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 请求类型，表示启动一个新的调试会话
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;#34;program&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;${workspaceFolder}/run.py&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 要调试的 Python 程序的路径（需要是一个可以运行的程序）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;#34;args&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="c1"&gt;//所有参数的列表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;thermal&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 第一个参数，表示运行模式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;-i&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 输入文件参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;${workspaceFolder}/case/3DIC_real_case/test_simulation.json&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 输入文件的路径
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;-o&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// 输出文件参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;${workspaceFolder}/case/3DIC_real_case/output&amp;#34;&lt;/span&gt; &lt;span class="c1"&gt;// 输出文件夹的路径
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;console&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;integratedTerminal&amp;#34;&lt;/span&gt; &lt;span class="c1"&gt;// 指定调试时使用的控制台类型，这里使用集成终端
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这段 JSON 配置文件是为 Visual Studio Code (VSCode) 中的调试器或运行器设置的，特别是用于运行 Python 脚本 &lt;code&gt;run.py&lt;/code&gt;。这是 VSCode 的 &lt;strong&gt;launch.json&lt;/strong&gt; 文件配置的一部分，用于设置如何运行 Python 程序以及传递的参数。下面是每个部分的解释：&lt;/p&gt;
&lt;h3 id="version-020"&gt;&lt;strong&gt;version&lt;/strong&gt;: &amp;ldquo;0.2.0&amp;rdquo;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;这是 VSCode 配置文件的版本号，表示该配置文件遵循的格式版本。&lt;code&gt;0.2.0&lt;/code&gt; 是比较老的版本，但它仍然被广泛使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="configurations-"&gt;&lt;strong&gt;configurations&lt;/strong&gt;: []
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;该数组包含一个或多个配置对象，每个配置代表一种不同的调试或运行方式。在这里，只有一个配置对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="配置对象解释"&gt;配置对象解释：
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;Python: Run run.py&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;python&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;request&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;program&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;${workspaceFolder}/run.py&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;args&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;thermal&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;-i&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;${workspaceFolder}/case/3DIC_real_case/test_simulation.json&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;-o&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;${workspaceFolder}/case/3DIC_real_case/output&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;console&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;integratedTerminal&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="name-python-run-runpy"&gt;&lt;strong&gt;name&lt;/strong&gt;: &lt;code&gt;&amp;quot;Python: Run run.py&amp;quot;&lt;/code&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这是配置的名称，用于标识和显示该配置。这个名称在 VSCode 的调试配置选择器中会出现，方便用户选择执行哪个配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="type-python"&gt;&lt;strong&gt;type&lt;/strong&gt;: &lt;code&gt;&amp;quot;python&amp;quot;&lt;/code&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这表示配置类型为 Python，告诉 VSCode 使用 Python 解释器来执行程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="request-launch"&gt;&lt;strong&gt;request&lt;/strong&gt;: &lt;code&gt;&amp;quot;launch&amp;quot;&lt;/code&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;该设置表明这是一个启动配置，而不是附加配置（&lt;code&gt;attach&lt;/code&gt;）。即，当点击 &amp;ldquo;启动&amp;rdquo; 或 &amp;ldquo;调试&amp;rdquo; 按钮时，VSCode 会运行这个配置来启动 Python 脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="program-workspacefolderrunpy"&gt;&lt;strong&gt;program&lt;/strong&gt;: &lt;code&gt;&amp;quot;${workspaceFolder}/run.py&amp;quot;&lt;/code&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;指定要执行的 Python 程序。&lt;code&gt;${workspaceFolder}&lt;/code&gt; 是一个内置变量，代表当前工作区的根文件夹路径。所以这里表示执行 &lt;code&gt;run.py&lt;/code&gt; 脚本，该脚本位于工作区根目录下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="args--thermal--i-workspacefoldercase3dic_real_casetest_simulationjson--o-workspacefoldercase3dic_real_caseoutput-"&gt;&lt;strong&gt;args&lt;/strong&gt;: &lt;code&gt;[ &amp;quot;thermal&amp;quot;, &amp;quot;-i&amp;quot;, &amp;quot;${workspaceFolder}/case/3DIC_real_case/test_simulation.json&amp;quot;, &amp;quot;-o&amp;quot;, &amp;quot;${workspaceFolder}/case/3DIC_real_case/output&amp;quot; ]&lt;/code&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这是传递给 Python 脚本 &lt;code&gt;run.py&lt;/code&gt; 的命令行参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;thermal&amp;quot;&lt;/code&gt;：传递给脚本的第一个参数，可能是某种运行模式或功能的标志。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;-i&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;${workspaceFolder}/case/3DIC_real_case/test_simulation.json&amp;quot;&lt;/code&gt;：&lt;code&gt;-i&lt;/code&gt; 可能是输入文件的标志，后面跟着路径指向一个 JSON 配置文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;-o&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;${workspaceFolder}/case/3DIC_real_case/output&amp;quot;&lt;/code&gt;：&lt;code&gt;-o&lt;/code&gt; 可能是输出目录或文件的标志，后面跟着路径指向输出目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些参数可以让 &lt;code&gt;run.py&lt;/code&gt; 根据输入的 JSON 配置文件进行仿真，并将结果输出到指定目录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="console-integratedterminal"&gt;&lt;strong&gt;console&lt;/strong&gt;: &lt;code&gt;&amp;quot;integratedTerminal&amp;quot;&lt;/code&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;该设置指定程序输出将在 VSCode 内部集成的终端中显示，而不是在外部终端中显示。这样，用户可以直接在 VSCode 的终端面板中查看程序输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="总结"&gt;总结：
&lt;/h3&gt;&lt;p&gt;这段配置文件的作用是设置一个 Python 调试或运行配置，在运行时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行 &lt;code&gt;run.py&lt;/code&gt; 脚本。&lt;/li&gt;
&lt;li&gt;传递三个命令行参数：&lt;code&gt;thermal&lt;/code&gt;（运行模式），&lt;code&gt;-i&lt;/code&gt; 后跟输入文件的路径，&lt;code&gt;-o&lt;/code&gt; 后跟输出目录的路径。&lt;/li&gt;
&lt;li&gt;输出将显示在 VSCode 的集成终端中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是设置调试或运行 Python 脚本的常见方式，尤其是在涉及到多个输入输出参数时。&lt;/p&gt;</description></item><item><title>一些芯片设计的冷知识</title><link>https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/</link><pubDate>Wed, 02 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/cover.png" alt="Featured image of post 一些芯片设计的冷知识" /&gt;&lt;h2 id="原理图-芯片物理版图"&gt;原理图-&amp;gt;芯片物理版图
&lt;/h2&gt;&lt;p&gt;根据电路设计图（也称为原理图或HDL代码）生成芯片物理版图&lt;/p&gt;
&lt;h3 id="逻辑综合"&gt;逻辑综合
&lt;/h3&gt;&lt;p&gt;这是将电路设计图转换为门级网表的过程，门级网表是由基本逻辑门（如与门、或门、非门等）和触发器（如D触发器、JK触发器等）组成的电路结构，它可以反映电路设计图的功能和性能。逻辑综合需要设定约束条件，就是希望综合出来的电路在面积、时序等目标参数上达到的标准；逻辑综合还需要指定基于的库，使用不同的综合库，在时序和面积上会有差异。常用的逻辑综合工具有Synopsys的Design Compiler，Cadence的PKS，Synplicity的Synplify等。&lt;/p&gt;
&lt;h3 id="布局规划"&gt;布局规划
&lt;/h3&gt;&lt;p&gt;这是在确定芯片的总体尺寸和形状后，将芯片中的各个模块（如IP核、存储器、I/O引脚等）分配到合适的位置的过程，布局规划需要考虑各个模块之间的连接关系、信号延迟、功耗分布、热效应等因素，以优化芯片的性能和可靠性。布局规划后，芯片的大小，Core的面积，Row的形式、电源及地线的Ring和Strip都确定下来了。常用的布局规划工具有Cadence的Encounter/Innovus，Synopsys的ICC等。&lt;/p&gt;
&lt;h3 id="时钟树综合"&gt;时钟树综合
&lt;/h3&gt;&lt;p&gt;这是在布局规划后，对芯片中的时钟信号进行专门的布线设计的过程，时钟信号在数字芯片中起着全局指挥作用，它需要对称地分配到各个寄存器单元，以保证时钟从同一个时钟源到达各个寄存器时，时钟延迟差异最小。时钟树综合需要考虑时钟频率、抖动、偏移等因素，以提高芯片的时序性能。常用的时钟树综合工具有Cadence Encounter/Innovus, Synopsys ICC, Synopsys PrimeTime SI等。&lt;/p&gt;
&lt;h3 id="布局布线"&gt;布局布线
&lt;/h3&gt;&lt;p&gt;这是将门级网表转换为具体的物理版图的过程，包括标准单元（如基本逻辑门电路）的放置和各种层之间的走线。布局布线需要遵循特定工艺的设计规则（如最小宽度、最小间距等），以保证版图可以被正确地加工出来。布局布线还需要考虑面积、功耗、时序、噪声、串扰等因素，以优化芯片的质量和效率。常用的布局布线工具有Cadence Encounter/Innovus, Synopsys ICC, Synopsys Astro等。&lt;/p&gt;
&lt;h3 id="物理验证"&gt;物理验证
&lt;/h3&gt;&lt;p&gt;这是在完成物理版图后，对其进行检查和修正的过程&lt;/p&gt;
&lt;h4 id="设计规则检查drc"&gt;设计规则检查（DRC）
&lt;/h4&gt;&lt;p&gt;这是检查物理版图是否符合工艺设计规则的过程，如果发现任何违反规则的地方，就需要进行修改。常用的设计规则检查工具有Synopsys的Hercules/ICV，Cadence的Assura/PVS，Mentor的Calibre等。&lt;/p&gt;
&lt;h4 id="布局与网表比较lvs"&gt;布局与网表比较（LVS）
&lt;/h4&gt;&lt;p&gt;这是检查物理版图是否与门级网表在功能上完全一致的过程，如果发现任何不匹配或缺失的地方，就需要进行调整。常用的布局与网表比较工具有Synopsys的Hercules/ICV，Cadence的Assura/PVS，Mentor的Calibre等。&lt;/p&gt;
&lt;h4 id="寄生参数提取pex"&gt;寄生参数提取（PEX）
&lt;/h4&gt;&lt;p&gt;这是从物理版图中提取出电阻、电容、电感等寄生参数的过程，这些参数会影响电路的性能和信号完整性，需要进行后仿真和分析。常用的寄生参数提取工具有Synopsys的Star-RC, Cadence的QRC, Mentor的Calibre XRC等。&lt;/p&gt;
&lt;h4 id="时序验证sta"&gt;时序验证（STA）
&lt;/h4&gt;&lt;p&gt;这是基于寄生参数提取的结果，对电路的时序性能进行验证的过程，主要检查电路是否存在建立时间（setup time）和保持时间（hold time）的违例，如果发现任何时序问题，就需要进行优化。常用的时序验证工具有Synopsys的PrimeTime, Cadence’s Tempus等。&lt;/p&gt;
&lt;h4 id="信号完整性分析si"&gt;信号完整性分析（SI）
&lt;/h4&gt;&lt;p&gt;这是基于寄生参数提取的结果，对电路的信号质量进行分析的过程，主要检查电路是否存在噪声、串扰、反射等问题，如果发现任何信号完整性问题，就需要进行改善。常用的信号完整性分析工具有Synopsys PrimeTime SI, Cadence Sigrity, Ansys Totem/Redhawk等。&lt;/p&gt;
&lt;p&gt;物理版图验证完成后，就可以将GDSII文件交给芯片代工厂（称为Foundry），在晶圆硅片上通过多道工艺步骤（如光刻、刻蚀、离子注入、沉积等）实现芯片的制造，再进行封装和测试，就得到了我们实际看见的芯片。&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/Jailman/article/details/132761728" target="_blank" rel="noopener"
&gt;一些芯片设计的冷知识&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="芯片键合bonding"&gt;芯片键合（bonding）
&lt;/h2&gt;&lt;p&gt;这个博主的其他文章也值得一看《傻白入门芯片设计系列》&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_46675545/article/details/128050411" target="_blank" rel="noopener"
&gt;傻白入门芯片设计，芯片键合(Die Bonding)（四）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_46675545/article/details/128053478" target="_blank" rel="noopener"
&gt;傻白入门芯片设计，典型的2D/2D+/2.5D/3D封装技术（六）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_46675545/article/details/128076797" target="_blank" rel="noopener"
&gt;傻白入门芯片设计，如何降低CPU功耗？（八）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="为什么还需要interposer层级"&gt;为什么还需要interposer层级
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;bump的大小是否符合和芯片I/O要求&lt;/li&gt;
&lt;li&gt;bump影响寄生参数值（根据电阻电感电容的公式推理即可. [Bump 越大，寄生电阻和寄生电感越小，但寄生电容越大。]&lt;/li&gt;
&lt;li&gt;更加灵活的互联（更短的互联路径）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="4d芯片集成"&gt;4D芯片集成
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://www.eet-china.com/mp/a352641.html" target="_blank" rel="noopener"
&gt;芯片的先进封装会发展到4D吗？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="dram预充电的作用"&gt;DRAM预充电的作用
&lt;/h2&gt;&lt;p&gt;预充电操作是为了“清空现场、重置电压”，以便 DRAM 可以正确执行下一次读写操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DRAM 的位线是差分信号线，感应放大器是通过对微小电压差放大来判断是 0 还是 1 的。如果前一次操作后电压还残留，就会影响下一次数据的正确性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;预充电 = 把位线电压“归一化”到 ½ 电压，为下次判别提供基准。不偏向 0，也不偏向 1&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;cell 电容&lt;/th&gt;
&lt;th&gt;位线电压&lt;/th&gt;
&lt;th&gt;连接后&lt;/th&gt;
&lt;th&gt;差值&lt;/th&gt;
&lt;th&gt;放大结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;存1&lt;/td&gt;
&lt;td&gt;Vdd&lt;/td&gt;
&lt;td&gt;Vdd/2&lt;/td&gt;
&lt;td&gt;位线稍↑&lt;/td&gt;
&lt;td&gt;+ΔV&lt;/td&gt;
&lt;td&gt;判为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存0&lt;/td&gt;
&lt;td&gt;0V&lt;/td&gt;
&lt;td&gt;Vdd/2&lt;/td&gt;
&lt;td&gt;位线稍↓&lt;/td&gt;
&lt;td&gt;-ΔV&lt;/td&gt;
&lt;td&gt;判为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;也就是说，cell 的电压通过连接到“Vdd/2”的位线上，形成一个微小的正/负波动，这时 Sense Amplifier 就可以把这个波动“放大”成逻辑 1 或 0。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;感应放大器只对微小差异敏感。若位线未被预充电，数据对比将发生偏移，导致：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据判别错误（读取出错）&lt;/p&gt;
&lt;p&gt;写入扰动（错误写入别的单元）&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_46675545/article/details/128210207" target="_blank" rel="noopener"
&gt;傻白入门芯片设计，史上最最最全DRAM介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/Tranquil_ovo/article/details/129876980" target="_blank" rel="noopener"
&gt;【DC】逻辑综合基础&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="lc谐振"&gt;LC谐振
&lt;/h2&gt;&lt;p&gt;电容，电感，反复充放电。
&lt;a class="link" href="https://zhuanlan.zhihu.com/p/532163425" target="_blank" rel="noopener"
&gt;还搞不懂 LC振荡电路原理？看这一文就够了，图文结合，立马带你搞定&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="正片和负片"&gt;正片和负片
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/weixin_42837669/article/details/110411765" target="_blank" rel="noopener"
&gt;PCB正片和负片的区别与使用&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="allegro加密文件密码破解和解除读写导出限制"&gt;Allegro加密文件密码破解和解除读写导出限制
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/vanfone/article/details/116275609" target="_blank" rel="noopener"
&gt;Allegro加密文件密码破解和解除读写导出限制&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="静态时序分析sta报告摘要"&gt;静态时序分析（STA）报告摘要
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image.png"
width="777"
height="368"
srcset="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image_hu_597ce37bf5508b64.png 480w, https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image_hu_3060480dc45bbc6.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="506px"
&gt;&lt;/p&gt;
&lt;p&gt;这张图展示的是数字后端设计中关键的 &lt;strong&gt;静态时序分析（STA）报告摘要&lt;/strong&gt; 和 &lt;strong&gt;设计规则违规（DRV）检查统计&lt;/strong&gt;，以下是详细解读：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="1-setup-mode-时序分析表"&gt;📍&lt;strong&gt;1. Setup Mode 时序分析表&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这部分列出了多种 &lt;strong&gt;路径类别（setup mode）&lt;/strong&gt; 的时序结果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WNS (ns)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Worst Negative Slack，最差路径的负裕量（最坏延迟）&lt;/td&gt;
&lt;td&gt;- 值为负数时说明时序违例。&lt;br&gt;- &lt;code&gt;all&lt;/code&gt; 模式下为 &lt;code&gt;-0.002ns&lt;/code&gt;，说明有轻微的时序违例。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TNS (ns)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Total Negative Slack，总的时序违例之和&lt;/td&gt;
&lt;td&gt;所有违反路径加总的延迟量。&lt;code&gt;-0.003ns&lt;/code&gt; 是非常轻微的问题。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Violating Paths&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;时序违例路径数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;all&lt;/code&gt; 模式下有 2 条路径违例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;All Paths&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;总路径数&lt;/td&gt;
&lt;td&gt;全设计共 12,273 条路径（时序分析覆盖）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;🔍 各模式说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;reg2reg&lt;/code&gt;: 从寄存器到寄存器的路径（主路径）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reg2cgate&lt;/code&gt;: 从寄存器到组合逻辑门（用于分析组合部分）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;: 默认路径类别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt;: 总体视角&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="2-drvsdesign-rule-violations-设计规则违规统计"&gt;📍&lt;strong&gt;2. DRVs：Design Rule Violations 设计规则违规统计&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这一部分列出的是违反电气规则（例如上限/转换时间等）的信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DRV 类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;结果解读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_cap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大负载电容违例&lt;/td&gt;
&lt;td&gt;共检测到 8 条网络超出上限（8 个实例），但&lt;strong&gt;没有真实违例值&lt;/strong&gt;（Worst Vio = 0），可能已修复。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_tran&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大信号转换时间违例&lt;/td&gt;
&lt;td&gt;检测到 6 条网络；Worst Vio 为 0.000，说明也已修复。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_fanout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大扇出&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_length&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大线长&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;📝 注：Real vs Total 表示是否是“实际有效违规”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Real：当前设计中真实存在的；&lt;/li&gt;
&lt;li&gt;Total：工具设置阈值检测到的超限数（可能已修复或忽略）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="3-density--routing-overflow"&gt;📍&lt;strong&gt;3. Density &amp;amp; Routing Overflow&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Density&lt;/strong&gt;: &lt;code&gt;46.432%&lt;/code&gt;
→ 标准单元填充密度，不高，布线空间充足。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Routing Overflow&lt;/strong&gt;: &lt;code&gt;0.00% H and 0.00% V&lt;/code&gt;
→ 布线拥塞情况非常理想，无水平或垂直溢出，说明布线非常顺畅。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="-总结"&gt;✅ 总结
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;结论&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;时序（STA）&lt;/td&gt;
&lt;td&gt;有轻微负 slack（-0.003ns），可继续优化，未严重超时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设计规则（DRV）&lt;/td&gt;
&lt;td&gt;所有电气规则违例已修复，0 违规&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;布局密度&lt;/td&gt;
&lt;td&gt;46%，空间富余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;布线拥塞&lt;/td&gt;
&lt;td&gt;0%，极佳&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;如你需要，我可以提供一些优化建议来消除 WNS/TNS。是否需要我帮你写个时序优化建议脚本或时序debug checklist？&lt;/p&gt;
&lt;h2 id="spef文件"&gt;SPEF文件
&lt;/h2&gt;&lt;p&gt;SPEF（Standard Parasitic Exchange Format）文件是一种 标准电路寄生参数交换文件，用于描述芯片设计中 电路的寄生参数信息，如：&lt;/p&gt;
&lt;p&gt;寄生电容（capacitance）&lt;/p&gt;
&lt;p&gt;寄生电阻（resistance）&lt;/p&gt;
&lt;p&gt;电感（如有）&lt;/p&gt;
&lt;p&gt;这些寄生参数主要来自于布线和互连，会影响信号延迟和电路时序，是时序分析（STA）和信号完整性分析（SI）不可或缺的数据源。&lt;/p&gt;
&lt;h2 id="cs中的前后端和ic中的前后端区别"&gt;CS中的前后端和IC中的前后端区别
&lt;/h2&gt;&lt;p&gt;这是个非常好的问题，很多初学者都会混淆“前端/后端”在 &lt;strong&gt;计算机科学（CS）&lt;/strong&gt; 和 &lt;strong&gt;数字IC设计&lt;/strong&gt; 这两个领域中的含义。以下是详细对比说明：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-一计算机科学cs中的前端与后端"&gt;🧠 一、&lt;strong&gt;计算机科学（CS）中的前端与后端&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这是你在 Web 开发、软件工程等方向常听到的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;维度&lt;/th&gt;
&lt;th&gt;前端（Frontend）&lt;/th&gt;
&lt;th&gt;后端（Backend）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;定义&lt;/td&gt;
&lt;td&gt;用户直接交互的部分&lt;/td&gt;
&lt;td&gt;处理逻辑、数据库、服务器的部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内容&lt;/td&gt;
&lt;td&gt;HTML、CSS、JavaScript、React、Vue 等&lt;/td&gt;
&lt;td&gt;Java、Python、Node.js、数据库、API、服务器逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;示例&lt;/td&gt;
&lt;td&gt;页面按钮、表单、界面动画&lt;/td&gt;
&lt;td&gt;用户登录验证、数据存取、接口开发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;技能栈&lt;/td&gt;
&lt;td&gt;Web UI、响应式设计、DOM 操作&lt;/td&gt;
&lt;td&gt;API 设计、数据库设计、系统架构、权限控制&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;✅ &lt;strong&gt;本质：前端关注“用户体验”，后端关注“数据与逻辑处理”。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-二数字ic设计中的前端与后端"&gt;🔧 二、&lt;strong&gt;数字IC设计中的前端与后端&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;这是在芯片设计（如 SoC、CPU）中使用的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;维度&lt;/th&gt;
&lt;th&gt;前端设计（Frontend Design）&lt;/th&gt;
&lt;th&gt;后端设计（Backend Design）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;定义&lt;/td&gt;
&lt;td&gt;描述电路功能逻辑&lt;/td&gt;
&lt;td&gt;实现功能的物理版图布局&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内容&lt;/td&gt;
&lt;td&gt;RTL 编写（Verilog/VHDL）、仿真、综合、形式验证&lt;/td&gt;
&lt;td&gt;布图布局（place &amp;amp; route）、时序收敛、DRC/LVS、RC提取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;工具&lt;/td&gt;
&lt;td&gt;ModelSim, VCS, DC（Design Compiler）等&lt;/td&gt;
&lt;td&gt;Innovus, ICC2, Calibre, StarRC 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;阶段&lt;/td&gt;
&lt;td&gt;- RTL Coding&lt;br&gt;- Functional Simulation&lt;br&gt;- Synthesis&lt;/td&gt;
&lt;td&gt;- Floorplan&lt;br&gt;- Placement&lt;br&gt;- CTS&lt;br&gt;- Routing&lt;br&gt;- DRC/LVS&lt;br&gt;- GDSII 生成&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;✅ &lt;strong&gt;本质：前端构建“逻辑电路”，后端实现“物理电路”。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-总结对比cs-vs-数字ic"&gt;🧩 总结对比：CS vs 数字IC
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;维度&lt;/th&gt;
&lt;th&gt;CS领域&lt;/th&gt;
&lt;th&gt;数字IC设计&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;前端&lt;/td&gt;
&lt;td&gt;用户界面、网页端&lt;/td&gt;
&lt;td&gt;RTL/功能设计&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;后端&lt;/td&gt;
&lt;td&gt;数据逻辑、服务器&lt;/td&gt;
&lt;td&gt;物理实现、布图布线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;工具语言&lt;/td&gt;
&lt;td&gt;JS, HTML, Python, Java&lt;/td&gt;
&lt;td&gt;Verilog, VHDL, Tcl, EDA工具&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="反相器版图"&gt;反相器版图
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-1.png"
width="748"
height="349"
srcset="https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-1_hu_88ed76e88ea28ac7.png 480w, https://sleepman9.github.io/p/%E4%B8%80%E4%BA%9B%E8%8A%AF%E7%89%87%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/image-1_hu_666f45b0143e3d2c.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="514px"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PMOS 的构造回顾&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PMOS 是放在 n-well 里的。&lt;/p&gt;
&lt;p&gt;它的源极和漏极是 p+ 掺杂区，栅是多晶硅，衬底是 n-well。&lt;/p&gt;
&lt;p&gt;要保证管子正常工作，n-well 必须接到高电位（VDD），防止 n-well 与源/漏之间形成寄生二极管导通。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;为什么要有 N+ 区&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 n-well 里放一个 N+ 区 并连接 VDD，是为了给 n-well 提供欧姆接触。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当金属和半导体直接接触时，会根据 功函数差和半导体掺杂浓度的不同，形成两种接触：&lt;/p&gt;
&lt;p&gt;肖特基接触 (Schottky Contact)：表现为整流特性，电阻较大。&lt;/p&gt;
&lt;p&gt;欧姆接触 (Ohmic Contact)：表现为线性 I–V 特性，电阻小。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;n-well/p-well 本身掺杂浓度比源/漏浅扩散区低很多，即使叫 “高掺杂”，跟源漏的 LDD 或深 N+ 仍然有差距。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;如果金属直接接在 well 上，不加一层高掺杂的 N+ (或 P+) 接触 implant，电阻会比较大。&lt;/p&gt;
&lt;p&gt;单纯的 n-well 是高掺杂 n 型，但与金属直接接触电阻很大。&lt;/p&gt;
&lt;p&gt;通过在 n-well 上打一个 N+ 接触区 (N+ diffusion)，电阻显著降低，形成良好的接触。&lt;/p&gt;
&lt;p&gt;这个 N+ 区并不是 PMOS 的源/漏区，它的作用是把 n-well 本身牢固地连到 VDD，称为 well tie 或 well contact。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;电气意义&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果不把 n-well 固定到 VDD，n-well 电位可能会“漂浮”，会产生 阈值电压漂移、漏电流增加甚至 latch-up 问题。&lt;/p&gt;
&lt;p&gt;N+ 区和金属接触到 VDD，就是为了固定住 n-well 电位。&lt;/p&gt;</description></item><item><title>无序映射-有序映射</title><link>https://sleepman9.github.io/p/%E6%97%A0%E5%BA%8F%E6%98%A0%E5%B0%84-%E6%9C%89%E5%BA%8F%E6%98%A0%E5%B0%84/</link><pubDate>Wed, 02 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E6%97%A0%E5%BA%8F%E6%98%A0%E5%B0%84-%E6%9C%89%E5%BA%8F%E6%98%A0%E5%B0%84/</guid><description>&lt;h2 id="无序映射stdunordered_map"&gt;无序映射（std::unordered_map）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输出结果是不确定的&lt;br&gt;
无序映射在插入、查找时平均时间复杂度为 O(1)，但遍历时顺序不确定；&lt;br&gt;
&lt;a class="link" href="https://www.hello-algo.com/chapter_hashing/hash_map/" target="_blank" rel="noopener"
&gt;哈希表&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unordered_map&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unordered_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;apple&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;banana&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;orange&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Unordered Map:&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nl"&gt;item&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="有序映射stdmap"&gt;有序映射（std::map）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输出结果是顺序的&lt;br&gt;
有序映射会自动对键进行排序，遍历时顺序按键排序，但时间复杂度为 O(log n)。&lt;br&gt;
&lt;a class="link" href="https://oi-wiki.org/ds/rbtree/" target="_blank" rel="noopener"
&gt;红黑树&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;map&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;apple&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;banana&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;orange&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Ordered Map:&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nl"&gt;item&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fruitCount&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;: &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="区别优缺点"&gt;区别优缺点
&lt;/h2&gt;&lt;p&gt;无序映射（std::unordered_map）和有序映射（std::map）的主要区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;底层数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序映射使用哈希表，键的存储顺序是无序的。&lt;/li&gt;
&lt;li&gt;有序映射使用红黑树（或其他平衡二叉树），键自动按排序规则排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;查找和插入效率&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序映射在平均情况下查找、插入和删除操作的时间复杂度为 O(1)，但最坏情况下可能退化到 O(n)。&lt;/li&gt;
&lt;li&gt;有序映射的这些操作时间复杂度为 O(log n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存使用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序映射由于哈希表的实现可能会占用更多的内存空间，用以维护桶以及处理哈希冲突。&lt;/li&gt;
&lt;li&gt;有序映射通常内存开销较小，主要存储树节点及指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;顺序性要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要按键顺序遍历数据，使用有序映射更方便。&lt;/li&gt;
&lt;li&gt;如果仅需要快速查找且不关心顺序，使用无序映射更优。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>中旗建材-星空科技-股权转让</title><link>https://sleepman9.github.io/p/%E4%B8%AD%E6%97%97%E5%BB%BA%E6%9D%90-%E6%98%9F%E7%A9%BA%E7%A7%91%E6%8A%80-%E8%82%A1%E6%9D%83%E8%BD%AC%E8%AE%A9/</link><pubDate>Tue, 01 Apr 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E4%B8%AD%E6%97%97%E5%BB%BA%E6%9D%90-%E6%98%9F%E7%A9%BA%E7%A7%91%E6%8A%80-%E8%82%A1%E6%9D%83%E8%BD%AC%E8%AE%A9/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E4%B8%AD%E6%97%97%E5%BB%BA%E6%9D%90-%E6%98%9F%E7%A9%BA%E7%A7%91%E6%8A%80-%E8%82%A1%E6%9D%83%E8%BD%AC%E8%AE%A9/cover.png" alt="Featured image of post 中旗建材-星空科技-股权转让" /&gt;&lt;p&gt;&lt;a class="link" href="./%e8%82%a1%e4%bb%bd%e8%bd%ac%e8%ae%a9.pdf" &gt;股份转让.pdf&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转让方（原股东）：卖出或转让股份的人或公司。&lt;br&gt;
受让方（新股东）：接收或购买股份的人或公司。&lt;/p&gt;&lt;/blockquote&gt;
&lt;img src="关系图.jpg" alt="关系图" style="width:70%;" /&gt;
&lt;h2 id="公司ipo关于壳的知识及原理"&gt;公司IPO关于“壳”的知识及原理
&lt;/h2&gt;</description></item><item><title>RNN(Recurrent Neural Networks-循环神经网络）</title><link>https://sleepman9.github.io/p/rnnrecurrent-neural-networks-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 31 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/rnnrecurrent-neural-networks-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</guid><description>&lt;img src="https://sleepman9.github.io/p/rnnrecurrent-neural-networks-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/cover.png" alt="Featured image of post RNN(Recurrent Neural Networks-循环神经网络）" /&gt;&lt;p&gt;RNN的目的使用来处理序列数据。在传统的神经网络模型中，是从输入层到隐含层再到输出层，层与层之间是全连接的，每层之间的节点是无连接的。但是这种普通的神经网络对于很多问题却无能无力。例如，你要预测句子的下一个单词是什么，一般需要用到前面的单词，因为一个句子中前后单词并不是独立的。RNN之所以称为循环神经网路，即一个序列当前的输出与前面的输出也有关。具体的表现形式为网络会对前面的信息进行记忆并应用于当前输出的计算中，即隐藏层之间的节点不再无连接而是有连接的，并且隐藏层的输入不仅包括输入层的输出还包括上一时刻隐藏层的输出。
&lt;img src="https://sleepman9.github.io/p/rnnrecurrent-neural-networks-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image.png"
width="1440"
height="446"
srcset="https://sleepman9.github.io/p/rnnrecurrent-neural-networks-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image_hu_479cb6247526a12b.png 480w, https://sleepman9.github.io/p/rnnrecurrent-neural-networks-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image_hu_30181f855693e293.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="774px"
&gt;&lt;/p&gt;
&lt;h2 id="基础-全连接层"&gt;基础-全连接层
&lt;/h2&gt;&lt;h3 id="code"&gt;code
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;span class="lnt"&gt;35
&lt;/span&gt;&lt;span class="lnt"&gt;36
&lt;/span&gt;&lt;span class="lnt"&gt;37
&lt;/span&gt;&lt;span class="lnt"&gt;38
&lt;/span&gt;&lt;span class="lnt"&gt;39
&lt;/span&gt;&lt;span class="lnt"&gt;40
&lt;/span&gt;&lt;span class="lnt"&gt;41
&lt;/span&gt;&lt;span class="lnt"&gt;42
&lt;/span&gt;&lt;span class="lnt"&gt;43
&lt;/span&gt;&lt;span class="lnt"&gt;44
&lt;/span&gt;&lt;span class="lnt"&gt;45
&lt;/span&gt;&lt;span class="lnt"&gt;46
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;torch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;torch.nn&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;nn&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;torch.optim&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;optim&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;torch.nn.functional&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;F&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 定义神经网络模型&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SimpleNN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Module&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;input_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_classes&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SimpleNN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fc1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Linear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 第一个全连接层&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fc2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Linear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 第二个全连接层&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fc3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Linear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_classes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 输出层，维度为类别数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;relu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fc1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# ReLU激活函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;relu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fc2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fc3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 最后一层不需要激活函数，因为我们会在损失函数中应用Softmax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 模型实例化&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;input_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt; &lt;span class="c1"&gt;# 假设输入数据的特征维度为128&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;num_classes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="c1"&gt;# 假设有10个类别&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SimpleNN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_classes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 打印模型结构&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 损失函数和优化器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;criterion&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CrossEntropyLoss&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# CrossEntropyLoss包含了Softmax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;optimizer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;optim&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Adam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;lr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.001&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 假设有一些数据用于训练&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# inputs: shape (batch_size, input_size)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# labels: shape (batch_size)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;inputs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;input_size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 32个样本，输入特征维度为128&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;labels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_classes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt; &lt;span class="c1"&gt;# 32个样本的标签，范围在0到9之间&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 训练步骤&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;outputs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 前向传播&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;loss&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;criterion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outputs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;labels&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 计算损失&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;optimizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zero_grad&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 清空梯度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;loss&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backward&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 反向传播&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;optimizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 更新参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 打印损失&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Loss: &lt;/span&gt;&lt;span class="si"&gt;{&lt;/span&gt;&lt;span class="n"&gt;loss&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="rnnlstmslong-short-term-memory长短时记忆模型模型"&gt;RNN&amp;ndash;LSTMs(Long Short-Term Memory，长短时记忆模型)模型
&lt;/h2&gt;&lt;h2 id="reference"&gt;Reference
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://zhuanlan.zhihu.com/p/30844905" target="_blank" rel="noopener"
&gt;一文搞懂RNN（循环神经网络）基础篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://dennybritz.com/posts/wildml/implementing-a-neural-network-from-scratch/" target="_blank" rel="noopener"
&gt;Implementing A Neural Network From Scratch in python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/yuyu_297/article/details/139036238#:~:text=%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%EF%BC%88fully%20connected,%E9%83%BD%E5%BD%B1%E5%93%8D%E6%AF%8F%E4%B8%AA%E8%BE%93%E5%87%BA%E3%80%82" target="_blank" rel="noopener"
&gt;卷积神经网络（CNN）自学笔记1：全连接层&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/heyongluoyao8/article/details/48636251" target="_blank" rel="noopener"
&gt;循环神经网络(RNN, Recurrent Neural Networks)介绍&lt;/a&gt;&lt;/p&gt;</description></item><item><title>手机SOC基础</title><link>https://sleepman9.github.io/p/%E6%89%8B%E6%9C%BAsoc%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 31 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E6%89%8B%E6%9C%BAsoc%E5%9F%BA%E7%A1%80/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E6%89%8B%E6%9C%BAsoc%E5%9F%BA%E7%A1%80/cover.png" alt="Featured image of post 手机SOC基础" /&gt;&lt;h2 id="手机soc包含的组件"&gt;手机SOC包含的组件
&lt;/h2&gt;&lt;h3 id="cpu"&gt;CPU：
&lt;/h3&gt;&lt;p&gt;在SOC里面，CPU的面积其实很小，但是它却很重要。ARM是一家英国的芯片设计公司，但是呢，它卖的不是芯片，而是芯片的授权。只有经过它授权，才能生产ARM架构的处理器。那么为什么主流的SOC都必须用ARM呢？在漫长的历史演变中，手机SOC也使用过其它架构，比如X86（PC端的处理器架构），但是都因为性能和功耗不理想，被淘汰了。&lt;/p&gt;
&lt;p&gt;ARM授权的同时，也给了一套公版内核方案，领到授权的芯片设计厂商，可以对公版内核进行大修改，也可以照搬。打个比方，ARM是一个生产熟食的厨师，各大芯片厂商（主妇们）可以将食物买回去直接吃，也可以对食物进行二次加工，让它变得更好吃。目前有“二次加工”能力的主要有苹果、高通、三星，海思在麒麟980上也迈出了第一步，其上所用A76内核有些修改。&lt;/p&gt;
&lt;p&gt;之前我也发布过一篇推文，讲美国将华为列入“实体名单”之后，华为不能使用新的架构，只能在现有ARMv8架构指令集（已经永久授权给了海思）的基础上进行魔改。而这个ARMv8架构，已经用了整整7年，这期间所有的内核都是基于它设计的，等于说先有架构，再有内核，一个架构可以衍生出多种内核。虽然这7年间由于工艺和设计水平的进步，手机CPU性能翻了很多倍，但是毕竟这么久了，也面临着换代，因此这才是华为“最大的危机”。&lt;/p&gt;
&lt;p&gt;现在的手机CPU普遍采用“大小核”的设计，不同内核组合起来。这里的“大小”是指芯片的大小，芯片面积越大，堆的晶体管越多，性能越强。打个比方，就像拉一车人去打架，你车越大，装的人越多，战斗力就越强，但是如果SOC全部都是大核，电池顶不住啊。以麒麟980为例，它采用2个A76大核，2个A76中核，4个A55小核的设计，根据不同的应用来决定开什么核，还是全部开，不同芯片设计厂商的调度不同，性能发挥也有差异。所以，手机CPU绝对不是核心数越多越好的，芯片厂商的设计至关重要。&lt;/p&gt;
&lt;h3 id="gpu"&gt;GPU
&lt;/h3&gt;&lt;p&gt;GPU全称是“图形处理器”，如字面含义，它负责处理图形数据，并向显示屏输送图形的任务，而智能手机上的SOC也要处理各种各样复杂的数据，因此也需要一个强大的GPU。ARM自己也有提供GPU方案，就是大名鼎鼎的Mali系列，这是目前较为主流的一种GPU，而高通则是自家的Adreno系列（其实跟AMD有很深的渊源）。&lt;/p&gt;
&lt;h3 id="npu"&gt;NPU
&lt;/h3&gt;&lt;p&gt;这可以说是最近两年的手机SOC才出现的新的芯片种类，它的全称叫neural-network process units，翻译成中文叫“嵌入式神经网络处理器”。这个名字听起来很高端，简单来说，它主要负责处理涉及神经网络算法和机器学习的海量数据，因为神经网络算法及机器学习需要处理大量信息，而当下的 CPU / GPU 都无法达到如此高效的处理能力，需要一个独立的处理芯片来做这个事，才有NPU的诞生。现在的“人工智能”AI的概念可以说非常火热，而NPU就是让手机变得更智能、更聪明的必要条件。&lt;/p&gt;
&lt;p&gt;目前，苹果A系列和海思麒麟系列都有独立的NPU，而高通则不然，它叫“AIE”，就是“人工智能引擎”的意思，它通过CPU+GPU+DSP来实现AI运算，也能达到比较强的AI算力。&lt;/p&gt;
&lt;h3 id="isp"&gt;ISP
&lt;/h3&gt;&lt;p&gt;很多人可能觉得，手机拍照的强弱只取决于传感器CMOS的强弱，殊不知，搭载同一款CMOS的同一品牌不同型号手机拍出来的效果可能略有差异。在这其中，SOC里面的ISP起到了至关重要的作用。&lt;/p&gt;
&lt;p&gt;ISP，全称Image Signal Processor，中文叫“图像处理器”，不是GPU的“图形处理器”哦！它负责接收感光原件CMOS的原始数据，对这些数据进行“粗加工”，得到最后我们看到的照片。ISP需要与CMOS匹配，为什么去年不少手机都没有用4800W像素的CMOS呢？很简单，去年高通旗舰SOC骁龙845不支持4800W像素，如图：&lt;/p&gt;
&lt;p&gt;骁龙845最高支持1600W像素&lt;/p&gt;
&lt;p&gt;所以去年的手机厂商都使用了IMX363或者IMX380这两款1200W像素的CMOS。&lt;/p&gt;
&lt;h3 id="dsp"&gt;DSP
&lt;/h3&gt;&lt;p&gt;DSP虽然看起来不起眼，但实际对手机体验影响很大。它全称叫Digital Signal Processor，中文名叫“数字信号处理器”，不仅在手机中应用，在雷达、通信、图像处理、医疗电子、工业机器人等高密集计算领域都有广泛应用。在手机上，它主要负责语音处理，包括通话和语音输入，也负责一些图像处理的任务。&lt;/p&gt;
&lt;h3 id="基带modem"&gt;基带(modem)
&lt;/h3&gt;&lt;p&gt;手机最根本的功能还是通信，而掌管通信的芯片叫基带芯片，也有人称之为“调制解调器modem”，但实际上，手机的基带芯片不止包含modem。这个调制解调器的主要作用就是负责信号传输——所谓调制，就是把需要传输的信号通过一定的规则调制到载波上，让后通过无线收发器发送出去；解调则是相反的过程，类似把基站的语言“翻译成”手机能懂的，从而保证双方的顺畅交流，使我们能够接打电话、连接网络。&lt;/p&gt;
&lt;p&gt;目前SOC上的基带有两种不同的形式：一种叫集成基带，即厂商有能力将基带集成到SOC中，比如海思和高通都有这个能力；另一种则需要外挂，例如苹果。这也解释了为何XS系列信号不佳，因为使用了Intel的外挂基带，这个基带表现不给力。手机要支持某种网络，需要对应的基带，比如当前火热的5G，高通X55和华为巴龙5000都是基带芯片，但现在的骁龙855和麒麟980都没有集成5G基带，因此你看到的5G手机都是外挂基带的。&lt;/p&gt;
&lt;h3 id="协处理器"&gt;协处理器
&lt;/h3&gt;&lt;p&gt;这个相对来说比较容易解释，就如同它的名字一样，它负责一些比较轻量级的数据处理任务，比如指南针、气压计等，不需要每次都唤醒CPU处理，从而节省电量。苹果很早就在A7处理器上引入了M7协处理器，其他厂商的SOC也渐渐跟进了。&lt;/p&gt;
&lt;h3 id="存储与内存控制"&gt;存储与内存控制
&lt;/h3&gt;&lt;h3 id="电源管理"&gt;电源管理
&lt;/h3&gt;&lt;h2 id="reference"&gt;Reference
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://zhuanlan.zhihu.com/p/419093227" target="_blank" rel="noopener"
&gt;掌中核心——手机SOC基础知识科普&lt;/a&gt;&lt;/p&gt;</description></item><item><title>神经网络入门</title><link>https://sleepman9.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 31 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/</guid><description>&lt;img src="https://sleepman9.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/cover.png" alt="Featured image of post 神经网络入门" /&gt;&lt;p&gt;推荐一篇写的很好的blog&lt;a class="link" href="https://www.ruanyifeng.com/blog/2017/07/neural-network.html" target="_blank" rel="noopener"
&gt;神经网络入门&lt;/a&gt;&lt;/p&gt;</description></item><item><title>AI_Model_Sep2Sep</title><link>https://sleepman9.github.io/p/ai_model_sep2sep/</link><pubDate>Fri, 28 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/ai_model_sep2sep/</guid><description>&lt;img src="https://sleepman9.github.io/p/ai_model_sep2sep/cover.png" alt="Featured image of post AI_Model_Sep2Sep" /&gt;&lt;p&gt;所谓Seq2Seq(Sequence to Sequence)，即序列到序列模型，就是一种能够根据给定的序列，通过特定的生成方法生成另一个序列的方法，同时这两个序列可以不等长。这种结构又叫Encoder-Decoder模型，即编码-解码模型，其是RNN的一个变种，为了解决RNN要求序列等长的问题。
&lt;img src="https://sleepman9.github.io/p/ai_model_sep2sep/image.png"
width="814"
height="244"
srcset="https://sleepman9.github.io/p/ai_model_sep2sep/image_hu_3bd048a127da8b7b.png 480w, https://sleepman9.github.io/p/ai_model_sep2sep/image_hu_271e770fefa577c7.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="333"
data-flex-basis="800px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你开始提问，那说明你开始进步了！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="seq2seq训练以及数据处理"&gt;Seq2Seq训练以及数据处理
&lt;/h2&gt;&lt;p&gt;就拿人机对话为例，我们输入一句话，机器输出对应回答的句子，处理方法如下：&lt;/p&gt;
&lt;p&gt;（1）假设有10000个问答句作为训练样本，我们统计得到1000个互异的字和每个字出现的次数；&lt;/p&gt;
&lt;p&gt;（2）根据统计得到的这1000个字，按照字数从多到少排序，即0-999结束，得到字典表；&lt;/p&gt;
&lt;p&gt;（3）基于得到字典表，对问答句进行one-hot编码；&lt;/p&gt;
&lt;p&gt;（4）由于编码难度较大且0多，我们进行embedding降维，得到特征矩阵；&lt;/p&gt;
&lt;p&gt;（5）得到特征矩阵后就可以作为输入，然后预测时输出的值是分类个数为1000的分类器，哪个概率最大预测所得就是对应的哪个字。&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference
&lt;/h2&gt;&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/zhuge2017302307/article/details/119979892" target="_blank" rel="noopener"
&gt;学习笔记十四——Seq2Seq模型&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Investment</title><link>https://sleepman9.github.io/p/investment/</link><pubDate>Fri, 28 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/investment/</guid><description>&lt;img src="https://sleepman9.github.io/p/investment/cover.jpg" alt="Featured image of post Investment" /&gt;&lt;blockquote&gt;
&lt;p&gt;Big Market决定了一家公司的上限。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="评估一家公司质地的指标"&gt;评估一家公司质地的指标
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/investment/%E6%94%B6%E6%94%AF%E6%8B%86%E8%A7%A3.jpg"
width="2670"
height="1200"
srcset="https://sleepman9.github.io/p/investment/%E6%94%B6%E6%94%AF%E6%8B%86%E8%A7%A3_hu_c6698bd3f0a516bb.jpg 480w, https://sleepman9.github.io/p/investment/%E6%94%B6%E6%94%AF%E6%8B%86%E8%A7%A3_hu_abaf1c272e628335.jpg 1024w"
loading="lazy"
alt="收支拆解"
class="gallery-image"
data-flex-grow="222"
data-flex-basis="534px"
&gt;&lt;/p&gt;
&lt;h3 id="归母净利润"&gt;归母净利润
&lt;/h3&gt;&lt;p&gt;归母净利润（归属于母公司股东的净利润，Net Profit Attributable to Parent Company）是企业财务报表中的一个关键指标，指的是企业在扣除所有成本、费用、税费后，最终归属于母公司股东的净利润。&lt;/p&gt;
$$
\text{归母净利润} = \text{净利润} - \text{少数股东损益}
$$&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;净利润：企业的总利润扣除所得税后的最终利润。&lt;/p&gt;
&lt;p&gt;少数股东损益：子公司中属于非母公司股东（少数股东）的部分利润。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;净利润:指企业在一定会计期间内，营业收入扣除营业成本、税费、各项费用、投资损益等后的最终利润，反映了企业的最终盈利水平。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="负债率"&gt;负债率
&lt;/h3&gt;$$ \text{负债率} = \frac{\text{总负债}}{\text{总资产}} \times 100\% $$&lt;p&gt;负债分有息负债与无息负债。有息负债指银行贷款可转债，发行债券等需要还本还息的借款。无息负债一般是指拖欠上下游的经营负债，要还本不用还息。当然如果公司足够强势，其实可以在资产负债表上形成一笔长期经营负债供公司使用。当然从我的角度出发，一切负债都是不稳定的因素。&lt;/p&gt;
&lt;p&gt;比如在经营困难的时候，负债是会压倒骆驼的最后一根稻草。我喜欢选择一些低负债率帐面现金多的公司，哪怕公司今年没有一分钱营业收入，把上下游欠款和银行贷款一还，还能靠着资产负债表的现金，产生投资收益利息收入，这样利润表上面不会出现亏损，分红也能持续。这一点很关键，它可以避免股票因为亏损而出现st。哪怕出现最糟糕的情况，清算价值也能拿回70%本金。&lt;/p&gt;
&lt;p&gt;流动比率也是一个衡量指标（流动资产/流动负债），这个指标可以反映企业的短期偿债能力，一般我喜欢这个指标大于2的企业。&lt;/p&gt;
&lt;h2 id="可转债的几个措施"&gt;可转债的几个措施
&lt;/h2&gt;&lt;h3 id="强赎"&gt;强赎
&lt;/h3&gt;&lt;p&gt;满足特定条件后，公司将可转债强制从持有人手中提前赎回。（强赎条件苛刻）&lt;/p&gt;
&lt;p&gt;满足强赎后为什么不发强赎条款 (&lt;a class="link" href="https://mp.weixin.qq.com/s/Pj1VF6vwEBqVhyHmGD7n1" target="_blank" rel="noopener"
&gt;https://mp.weixin.qq.com/s/Pj1VF6vwEBqVhyHmGD7n1&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id="回售"&gt;回售
&lt;/h3&gt;&lt;p&gt;股价下跌太厉害，要求公司赎回转债。&lt;/p&gt;
&lt;h3 id="下修"&gt;下修
&lt;/h3&gt;&lt;p&gt;股价下跌太厉害，修改转股价值，将可转债的价格拉回到100面值左右。&lt;/p&gt;</description></item><item><title>Template Format</title><link>https://sleepman9.github.io/p/format/</link><pubDate>Thu, 27 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/format/</guid><description>&lt;img src="https://sleepman9.github.io/p/format/cover.jpg" alt="Featured image of post Template Format" /&gt;&lt;h2 id="颜色块-提示"&gt;颜色块-提示
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Photo by &lt;a class="link" href="https://unsplash.com/@pawel_czerwinski" target="_blank" rel="noopener"
&gt;Pawel Czerwinski&lt;/a&gt; on &lt;a class="link" href="https://unsplash.com/" target="_blank" rel="noopener"
&gt;Unsplash&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="可视化展示"&gt;可视化展示
&lt;/h2&gt;&lt;!-- https://github.com/kyechan99/capsule-render --&gt;
&lt;p align="center"&gt;
&lt;img src="https://capsule-render.vercel.app/api?type=waving&amp;height=300&amp;color=timeGradient&amp;text=Raincarnator&amp;desc=Programming%20/%20Design%20/%20ACGN&amp;descAlignY=54&amp;fontAlignY=40&amp;fontSize=80&amp;descAlign=62&amp;animation=fadeIn" /&gt;
&lt;/p&gt;
&lt;p align="center"&gt;
&lt;p align="center"&gt;你好，我是&lt;b&gt;失迹&lt;/b&gt;。&lt;br/&gt;一位 &lt;b&gt;编程 / 设计 / ACGN&lt;/b&gt; 爱好者。&lt;/p&gt;
&lt;p align="center"&gt;Hi, I am &lt;b&gt;Raincarnator&lt;/b&gt;.&lt;br/&gt;A &lt;b&gt;Programming / Design / ACGN&lt;/b&gt; enthusiast.&lt;/p&gt;
&lt;/p&gt;
&lt;p align="center"&gt;
&lt;!-- https://github.com/anuraghazra/github-readme-stats --&gt;
&lt;img align="center" width="400" src="https://github-readme-stats.vercel.app/api?username=Raincarnator&amp;theme=transparent&amp;show_icons=true&amp;hide_border=true&amp;rank_icon=github" /&gt;
&lt;!-- https://github.com/DenverCoder1/github-readme-streak-stats --&gt;
&lt;img align="center" width="400" src="https://streak-stats.demolab.com?user=Raincarnator&amp;theme=transparent&amp;date_format=%5BY.%5Dn.j&amp;hide_border=true" /&gt;
&lt;br/&gt;
&lt;!-- https://github.com/Ashutosh00710/github-readme-activity-graph --&gt;
&lt;img width="800" src="https://github-readme-activity-graph.vercel.app/graph?username=Raincarnator&amp;theme=github-compact&amp;hide_border=true&amp;area=true" /&gt;
&lt;br/&gt;
&lt;!-- https://github.com/anuraghazra/github-readme-stats --&gt;
&lt;img align="center" src="https://github-readme-stats.vercel.app/api/wakatime?username=ArauKaede&amp;theme=transparent&amp;hide_border=true&amp;layout=compact&amp;langs_count=22" /&gt;
&lt;!-- https://github.com/anuraghazra/github-readme-stats --&gt;
&lt;img align="center" src="https://github-readme-stats.vercel.app/api/top-langs/?username=Raincarnator&amp;theme=transparent&amp;hide_border=true&amp;layout=donut-vertical&amp;langs_count=6" /&gt;
&lt;br/&gt;
&lt;!-- https://github.com/tandpfun/skill-icons --&gt;
&lt;img align="center" src="https://skillicons.dev/icons?i=cpp,kotlin,html,css,js,ts,java,md,latex,windows,vscode,androidstudio,ps,azure,netlify,cloudflare,github,git,npm,materialui&amp;theme=light&amp;perline=10" /&gt;
&lt;/p&gt;
&lt;!-- https://github.com/badges/shields --&gt;
&lt;p align="center"&gt;
&lt;a href="https://wakatime.com/@ArauKaede"&gt;&lt;img src="https://wakatime.com/badge/user/9b029946-d3d7-4021-993b-1ee294b8297a.svg" &gt;&lt;/a&gt;
&lt;img src="https://komarev.com/ghpvc/?username=Raincarnator&amp;abbreviated=true"/&gt;
&lt;img src="https://img.shields.io/github/stars/Raincarnator?style=flat&amp;logoColor=%231677ff&amp;labelColor=rgb(89, 89, 89)&amp;color=rgb(3, 126, 187)"/&gt;
&lt;img src="https://img.shields.io/github/followers/Raincarnator?style=flat&amp;logoColor=%231677ff&amp;labelColor=rgb(89, 89, 89)&amp;color=rgb(3, 126, 187)"/&gt;
&lt;/p&gt;
&lt;!-- https://github.com/kyechan99/capsule-render --&gt;
&lt;p align="center"&gt;
&lt;img src="https://capsule-render.vercel.app/api?type=waving&amp;height=300&amp;color=timeGradient&amp;text=Flowers%20will%20bloom%20in%20the%20world,%20and%20magnificent%20and%20immortal%20things%20will%20follow.&amp;desc=Reincarnatey%20Network%20Co.,%20Ltd&amp;descAlignY=93&amp;fontAlignY=60&amp;fontSize=20&amp;descAlign=50&amp;animation=fadeIn&amp;descSize=15&amp;section=footer&amp;fontAlign=50" /&gt;
&lt;/p&gt;
&lt;h2 id="video"&gt;video
&lt;/h2&gt;&lt;p&gt;For more details, check out the &lt;a class="link" href="https://stack.jimmycai.com/writing/shortcodes" target="_blank" rel="noopener"
&gt;documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="bilibili-video"&gt;Bilibili video
&lt;/h3&gt;
&lt;div class="video-wrapper"&gt;
&lt;iframe src="https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1d4411N7zD"
scrolling="no"
frameborder="no"
framespacing="0"
allowfullscreen="true"
&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;h3 id="tencent-video"&gt;Tencent video
&lt;/h3&gt;
&lt;div class="video-wrapper"&gt;
&lt;iframe src="https://v.qq.com/txp/iframe/player.html?vid=g0014r3khdw&amp;auto=0"
scrolling="no"
frameborder="no"
framespacing="0"
allowfullscreen="true"
&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;h3 id="youtube-video"&gt;YouTube video
&lt;/h3&gt;&lt;div class="video-wrapper"&gt;
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/0qwALOOvUik"
allowfullscreen
title="YouTube Video"
&gt;
&lt;/iframe&gt;
&lt;/div&gt;
&lt;h3 id="generic-video-file"&gt;Generic video file
&lt;/h3&gt;&lt;div class="video-wrapper"&gt;
&lt;video
controls
src="https://www.w3schools.com/tags/movie.mp4"
&gt;
&lt;p&gt;
Your browser doesn't support HTML5 video. Here is a
&lt;a href="https://www.w3schools.com/tags/movie.mp4"&gt;link to the video&lt;/a&gt; instead.
&lt;/p&gt;
&lt;/video&gt;
&lt;/div&gt;
&lt;h2 id="gist"&gt;Gist
&lt;/h2&gt;&lt;script src="https://gist.github.com/CaiJimmy/e2751a943de10b2a5b3a8a6c2120cb86.js"&gt;&lt;/script&gt;
&lt;h2 id="gitlab"&gt;GitLab
&lt;/h2&gt;&lt;script
type="application/javascript"
src="https://gitlab.com/-/snippets/2589724.js"
&gt;&lt;/script&gt;
&lt;h2 id="quote"&gt;Quote
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/p&gt;&lt;span class="cite"&gt;&lt;span&gt;― &lt;/span&gt;&lt;span&gt;A famous person, &lt;/span&gt;&lt;a href="https://en.wikipedia.org/wiki/Book"&gt;&lt;cite&gt;The book they wrote&lt;/cite&gt;&lt;/a&gt;&lt;/span&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="锚点链接"&gt;锚点链接
&lt;/h2&gt;&lt;h3 id="-标准做法通过标题跳转推荐"&gt;✅ 标准做法：通过标题跳转（推荐）
&lt;/h3&gt;&lt;p&gt;Markdown 中每个标题（&lt;code&gt;#&lt;/code&gt; 开头的那种）会自动生成一个锚点，你可以用它来链接。&lt;/p&gt;
&lt;h4 id="例子"&gt;例子：
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-markdown" data-lang="markdown"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="gh"&gt;# 无序列表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="gh"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;-&lt;/span&gt; 项目一
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;-&lt;/span&gt; 项目二
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;-&lt;/span&gt; 项目三
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;[&lt;span class="nt"&gt;跳转到无序列表&lt;/span&gt;](&lt;span class="na"&gt;#无序列表&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;✔️点击“跳转到无序列表”会定位到标题“无序列表”。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠️ 如果你非要链接到&lt;strong&gt;无序列表中的某项&lt;/strong&gt;（不是标题），标准 Markdown &lt;strong&gt;不支持自动为列表项生成锚点&lt;/strong&gt;，但有以下几种变通方法：&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id="-方法-1人为加标题辅助跳转"&gt;✅ 方法 1：人为加标题辅助跳转
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-markdown" data-lang="markdown"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="gu"&gt;### 项目一 {#item1}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="gu"&gt;&lt;/span&gt;&lt;span class="k"&gt;-&lt;/span&gt; 描述内容
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;[&lt;span class="nt"&gt;跳转到项目一&lt;/span&gt;](&lt;span class="na"&gt;#item1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;✔️注意这里的 &lt;code&gt;{#item1}&lt;/code&gt; 是一些 Markdown 渲染器（比如 GitBook、Typora、Hugo）支持的&lt;strong&gt;手动锚点语法&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-方法-2加隐藏标题用于跳转"&gt;✅ 方法 2：加隐藏标题（用于跳转）
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-markdown" data-lang="markdown"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&amp;lt;span id=&amp;#34;item2&amp;#34;&amp;gt;&amp;lt;/span&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;-&lt;/span&gt; 项目二：这里是第二项
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;[&lt;span class="nt"&gt;跳转到项目二&lt;/span&gt;](&lt;span class="na"&gt;#item2&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;✔️这个用 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 标签定义锚点，大多数 Markdown 引擎都支持。&lt;/p&gt;
&lt;h2 id="分页"&gt;分页
&lt;/h2&gt;&lt;p&gt;Markdown 本身 不支持分页，因为它是一种纯文本标记语言，设计目的是用于网页、文档等平台上的内容结构整理，没有“分页”这个概念。但根据你使用的平台或输出格式，可以用不同的技巧实现类似分页的效果&lt;/p&gt;
&lt;p&gt;导出PDF&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-markdown" data-lang="markdown"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&amp;lt;div style=&amp;#34;page-break-after: always;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>Tools Trick</title><link>https://sleepman9.github.io/p/tools-trick/</link><pubDate>Mon, 24 Mar 2025 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/p/tools-trick/</guid><description>&lt;img src="https://sleepman9.github.io/p/tools-trick/cover.jpg" alt="Featured image of post Tools Trick" /&gt;&lt;h2 id="1-vscode中github-copilot在ssh远程环境中无法登录问题"&gt;1. VSCode中Github Copilot在SSH远程环境中无法登录问题
&lt;/h2&gt;&lt;h3 id="1-在vs-code中按f1键调出命令行输入settingsjson选择远程环境中的配置文件"&gt;1. 在VS Code中，按F1键调出命令行，输入settings.json，选择远程环境中的配置文件：
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://sleepman9.github.io/p/tools-trick/asserts/copliot.png"
width="825"
height="502"
srcset="https://sleepman9.github.io/p/tools-trick/asserts/copliot_hu_d04c34523884441.png 480w, https://sleepman9.github.io/p/tools-trick/asserts/copliot_hu_f6631b22a2511959.png 1024w"
loading="lazy"
alt="alt text"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
&gt;&lt;/p&gt;
&lt;h3 id="2-添加如下配置"&gt;2. 添加如下配置：
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;remote.extensionKind&amp;#34;&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;GitHub.copilot&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;ui&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;GitHub.copilot-chat&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;ui&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="3-重启vs-code即可"&gt;3. 重启VS Code即可。
&lt;/h3&gt;&lt;p&gt;&lt;a class="link" href="https://blog.csdn.net/qq_43948052/article/details/146123406" target="_blank" rel="noopener"
&gt;原文链接&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Archives</title><link>https://sleepman9.github.io/archives/</link><pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/archives/</guid><description/></item><item><title>Links</title><link>https://sleepman9.github.io/links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/links/</guid><description>&lt;!-- To use this feature, add `links` section to frontmatter.
This page's frontmatter:
```yaml
links:
- title: GitHub
description: GitHub is the world's largest software development platform.
website: https://github.com
image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png
- title: TypeScript
description: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
website: https://www.typescriptlang.org
image: ts-logo-128.jpg
```
`image` field accepts both local and external images. --&gt;</description></item><item><title>Search</title><link>https://sleepman9.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sleepman9.github.io/search/</guid><description/></item></channel></rss>